name: Issue Branch PR Workflow

on:
  issues:
    types: [opened, assigned, labeled]
  pull_request:
    types: [opened, closed, synchronize]
  workflow_dispatch:
  schedule:
    - cron: '0 2 * * 0'

permissions:
  contents: write
  issues: write
  pull-requests: write

jobs:
  create-branch:
    name: Create Branch from Issue
    if: github.event_name == 'issues' && (github.event.action == 'opened' || github.event.action == 'assigned')
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0
      - name: Setup Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
      - name: Create issue branch
        id: create_branch
        run: |
          ISSUE_NUMBER="${{ github.event.issue.number }}"
          ISSUE_TITLE="${{ github.event.issue.title }}"
          CLEAN_TITLE=$(echo "$ISSUE_TITLE" | sed 's/[^a-zA-Z0-9 ]//g' | tr '[:upper:]' '[:lower:]' | sed 's/ /-/g' | sed 's/--*/-/g' | sed 's/^-|-$//g' | cut -c1-50)
          BRANCH_NAME="issue-${ISSUE_NUMBER}-${CLEAN_TITLE}"
          echo "Creating branch: $BRANCH_NAME"
          if git ls-remote --heads origin "$BRANCH_NAME" | grep -q "$BRANCH_NAME"; then
            echo "Branch $BRANCH_NAME already exists"
            echo "branch_exists=true" >> $GITHUB_OUTPUT
          else
            git checkout -b "$BRANCH_NAME"
            git push origin "$BRANCH_NAME"
            echo "branch_exists=false" >> $GITHUB_OUTPUT
            echo "Branch $BRANCH_NAME created successfully"
          fi
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      - name: Comment on issue
        if: steps.create_branch.outputs.branch_exists == 'false'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const branchName = '${{ steps.create_branch.outputs.branch_name }}';
            const issueNumber = context.issue.number;
            const comment = `üîÄ **Branch Created**
A new branch has been created for this issue:
- Branch: \`${branchName}\`
- You can start working on this issue by checking out the branch

\`\`\`bash
git fetch origin
git checkout ${branchName}
\`\`\`

**What you can do:**
- Commit and push changes to this branch
- Open a pull request referencing the issue

**What you cannot do:**
- Merge to \`main\` or \`dev\` without maintainer/owner review and certification
- Bypass code review or branch protection

When ready, create a pull request to merge your changes!`;
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body: comment
            });

  auto-create-pr:
    name: Auto Create Pull Request
    if: github.event_name == 'issues' && github.event.action == 'labeled' && github.event.label.name == 'ready-for-pr'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0
      - name: Find and create PR for issue branch
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const issue = context.payload.issue;
            const issueNumber = issue.number;
            const cleanTitle = issue.title.replace(/[^a-zA-Z0-9 ]/g, '').toLowerCase().replace(/\s+/g, '-').replace(/-+/g, '-').replace(/^-|-$|/g, '').substring(0, 50);
            const branchName = `issue-${issueNumber}-${cleanTitle}`;
            try {
              await github.rest.repos.getBranch({ owner: context.repo.owner, repo: context.repo.repo, branch: branchName });
              const { data: existingPRs } = await github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                head: `${context.repo.owner}:${branchName}`,
                state: 'open'
              });
              if (existingPRs.length > 0) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  body: `üîÑ **Pull Request Already Exists**
A pull request already exists for this issue:
- PR: #${existingPRs[0].number}
- Branch: \`${branchName}\`
[View Pull Request](${existingPRs[0].html_url})`
                });
                return;
              }
              const { data: newPR } = await github.rest.pulls.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `Fix #${issueNumber}: ${issue.title}`,
                head: branchName,
                base: 'main',
                body: `Fixes #${issueNumber}\n\nAuto-created PR for issue branch.`,
                draft: false
              });
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                body: `üöÄ **Pull Request Created**
A pull request has been automatically created for this issue:
- PR: #${newPR.number}
- Branch: \`${branchName}\`
[View Pull Request](${newPR.html_url})`
              });
            } catch (error) {
              if (error.status === 404) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  body: `‚ùå **Branch Not Found**
Could not find branch \`${branchName}\` for this issue.`
                });
              } else {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  body: `‚ùå **Error Creating Pull Request**
An error occurred while creating the pull request: ${error.message}`
                });
              }
            }

  enforce-strict-pr-security:
    name: Enforce Maintainer/Owner-Only Merge and PR Rules
    if: github.event_name == 'pull_request' && (github.event.action == 'opened' || github.event.action == 'synchronize')
    runs-on: ubuntu-latest
    steps:
      - name: Block non-maintainer PRs to protected branches and enforce issue reference
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const pr = context.payload.pull_request;
            const username = pr.user.login;
            const baseBranch = pr.base.ref;
            const prTitle = pr.title || '';
            const prBody = pr.body || '';
            const maintainers = [
              'gamingisrealyt'
              // Add more usernames if you have more maintainers/owners
            ];
            // Only allow maintainers/owners to open PRs to main/dev
            if ((baseBranch === 'main' || baseBranch === 'dev') && !maintainers.includes(username)) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                body: `üö´ **Security Policy**

Only maintainers/owners from [gamingisrealyt](https://github.com/gamingisrealyt) can merge code directly to \`${baseBranch}\`.

**What you can do:**
- Work on an issue branch (e.g. \`issue-123-description\`)
- Request a review from a maintainer/owner

**What you cannot do:**
- Merge to \`${baseBranch}\` without maintainer/owner approval and certification
- Bypass code review or branch protection

**Certification Required:**  
All code must be checked and certified by a maintainer/owner before merging to \`${baseBranch}\`.  
Your PR will be closed. If you believe this is a mistake, contact a repository maintainer or owner.`
              });
              await github.rest.pulls.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number,
                state: 'closed'
              });
              return;
            }
            // Require PR title or body to reference an issue
            if (!prTitle.match(/#\d+/) && !prBody.match(/#\d+/)) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                body: `‚ö†Ô∏è **PR Must Reference an Issue**
Your PR title or description must reference an issue (e.g., "Fix #123: ...").
Please update your PR. This PR will be closed.`
              });
              await github.rest.pulls.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number,
                state: 'closed'
              });
            }
