name: Repository Protection

on:
  workflow_dispatch:
    inputs:
      action:
        description: 'Protection action to perform'
        required: true
        type: choice
        options: [lock-it-down, remove-protection, emergency-unlock, status-check]
      confirmation:
        description: 'Type "CONFIRM" to proceed (not needed for status-check)'
        required: false
        type: string
      approval_count:
        description: 'Required approvals (1-6)'
        required: true
        default: '2'
        type: choice
        options: ['1','2','3','4','5','6']
      bypass_admin:
        description: 'Allow admin bypass in emergencies?'
        required: true
        default: 'false'
        type: choice
        options: ['true','false']
      maintainer_username:
        description: 'Additional maintainer GitHub username (optional)'
        required: false
        type: string

  schedule:
    - cron: '0 2 * * *'  # Run at 2 AM UTC daily

permissions:
  contents: write
  issues: write
  pull-requests: write
  actions: read
  security-events: write

env:
  PROTECTION_LABEL: 'repo-protection-status'
  EMERGENCY_LABEL: 'emergency-unlock'

jobs:
  validate-user:
    runs-on: ubuntu-latest
    outputs:
      authorized: ${{ steps.check.outputs.authorized }}
      user_role: ${{ steps.check.outputs.user_role }}
    steps:
      - name: Validate user permissions
        id: check
        run: |
          maintainer="${{ github.event.inputs.maintainer_username }}"
          
          # Empty maintainer check - treat empty string as no maintainer
          if [ -z "$maintainer" ]; then
            maintainer="NONE_SET"
          fi
          
          if [ "${{ github.actor }}" != "${{ github.repository_owner }}" ] && [ "${{ github.actor }}" != "$maintainer" ]; then
            echo "authorized=false" >> $GITHUB_OUTPUT
            echo "user_role=unauthorized" >> $GITHUB_OUTPUT
            echo "::error::User ${{ github.actor }} is not authorized. Only owner or maintainer can run this workflow."
            exit 1
          fi
          
          if [ "${{ github.actor }}" == "${{ github.repository_owner }}" ]; then
            echo "user_role=owner" >> $GITHUB_OUTPUT
          else
            echo "user_role=maintainer" >> $GITHUB_OUTPUT
          fi
          echo "authorized=true" >> $GITHUB_OUTPUT

  cleanup-old-branches:
    needs: validate-user
    if: needs.validate-user.outputs.authorized == 'true' && github.event_name == 'schedule'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Delete old branches
        run: |
          git fetch --prune origin
          
          # Get list of branches excluding protected ones
          branches=$(git branch -r | grep -v "HEAD\|main\|master" | sed 's/origin\///' || true)
          
          if [ -z "$branches" ]; then
            echo "No branches to process"
            exit 0
          fi
          
          for branch in $branches; do
            # Trim whitespace
            branch=$(echo "$branch" | xargs)
            
            # Skip if empty
            if [ -z "$branch" ]; then
              continue
            fi
            
            # Check if branch exists and get last commit time
            if git rev-parse --verify "origin/$branch" >/dev/null 2>&1; then
              last_commit=$(git log -1 --format=%at "origin/$branch" 2>/dev/null || echo "0")
              current_time=$(date +%s)
              days_old=$(( ($current_time - $last_commit) / 86400 ))
              
              if [ $days_old -gt 30 ]; then
                echo "Deleting old branch: $branch (${days_old} days old)"
                git push origin --delete "$branch" || echo "Failed to delete $branch, continuing..."
              else
                echo "Branch $branch is only $days_old days old, keeping"
              fi
            else
              echo "Branch $branch no longer exists, skipping"
            fi
          done

  apply-protection:
    needs: validate-user
    if: |
      needs.validate-user.outputs.authorized == 'true' && 
      github.event.inputs.action == 'lock-it-down'
    runs-on: ubuntu-latest
    steps:
      - name: Validate confirmation
        run: |
          if [ "${{ github.event.inputs.confirmation }}" != "CONFIRM" ]; then
            echo "::error::Confirmation required. Please type 'CONFIRM' in the confirmation field to proceed."
            exit 1
          fi
      
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Setup branch protection
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const approvals = parseInt('${{ github.event.inputs.approval_count }}');
            const bypassAdmin = '${{ github.event.inputs.bypass_admin }}' === 'true';
            
            console.log(`Applying protection with ${approvals} required approvals`);
            console.log(`Admin bypass: ${bypassAdmin}`);
            
            for (const branch of ['main', 'master']) {
              try {
                await github.rest.repos.updateBranchProtection({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  branch: branch,
                  required_status_checks: {
                    strict: true,
                    contexts: ['security-scan']
                  },
                  enforce_admins: !bypassAdmin,
                  required_pull_request_reviews: {
                    required_approving_review_count: approvals,
                    dismiss_stale_reviews: true,
                    require_code_owner_reviews: true
                  },
                  restrictions: null,
                  allow_force_pushes: false,
                  allow_deletions: false,
                  required_conversation_resolution: true
                });
                console.log(`[SUCCESS] Protected ${branch} branch`);
              } catch (e) {
                if (e.status === 404) {
                  console.log(`[SKIP] Branch ${branch} not found, skipping`);
                } else {
                  console.error(`[FAILED] Could not protect ${branch}: ${e.message}`);
                  throw e;
                }
              }
            }

  create-security-guidelines:
    name: Post Security Guidelines
    needs: [validate-user, apply-protection]
    if: |
      needs.validate-user.outputs.authorized == 'true' && 
      github.event.inputs.action == 'lock-it-down' &&
      needs.apply-protection.result == 'success'
    runs-on: ubuntu-latest
    steps:
      - name: Post security guideline issue
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const maintainer = '${{ github.event.inputs.maintainer_username }}';
            const owner = '${{ github.repository_owner }}';
            const reviewers = maintainer ? `@${owner} and @${maintainer}` : `@${owner}`;
            const approvals = '${{ github.event.inputs.approval_count }}';

            // Close any existing open security-guidelines issues first
            const { data: existing } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: ['security-guidelines'],
              state: 'open'
            });
            
            for (const issue of existing) {
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                state: 'closed',
                state_reason: 'completed'
              });
              console.log(`Closed previous security guidelines issue #${issue.number}`);
            }

            const newIssue = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: 'LOCKDOWN: Security Rules and Contribution Guidelines',
              body: `# Repository Security Rules

This repository is under strict security protection.

---

## Allowed Actions
- Branch off main or master
- Open pull requests for changes
- Pass the security-scan check
- Get ${approvals} approvals plus code owner review
- Fix issues raised in reviews

## Forbidden Actions
- Direct pushes to protected branches
- Merging PRs without required approvals
- Merging with failing security-scan
- Merging with unresolved conversations
- Adding forbidden files (.pem, .key, .p12, .env, /secrets/)
- Committing secrets (tokens, API keys, passwords, private keys)
- Force pushing or deleting branches

---

WARNING: PRs with forbidden files or secrets will be automatically CLOSED by the bot.

Maintainers: ${reviewers}
Activated by: @${{ github.actor }}
This issue is pinned for contributor reference`,
              labels: ['security-guidelines', 'documentation', 'pinned']
            });
            
            console.log(`Created security guidelines issue #${newIssue.data.number}`);

  security-scan:
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' || github.event_name == 'push'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Scan for secrets and forbidden files
        run: |
          echo "Starting security scan..."
          
          # Check for forbidden files
          forbidden_files=$(find . -type f \( -name "*.pem" -o -name "*.key" -o -name "*.p12" -o -name ".env" \) -o -path "*/secrets/*" 2>/dev/null | grep -v ".git" || true)
          
          if [ -n "$forbidden_files" ]; then
            echo "::error::Found forbidden files:"
            echo "$forbidden_files"
            exit 1
          fi
          
          echo "No forbidden files found"
          
          # Check for potential secrets in changes (only on push events with valid before SHA)
          if [ "${{ github.event_name }}" == "push" ]; then
            before_sha="${{ github.event.before }}"
            after_sha="${{ github.sha }}"
            
            # Check if this is not the initial commit
            if [ "$before_sha" != "0000000000000000000000000000000000000000" ]; then
              echo "Checking for secrets in diff between $before_sha and $after_sha"
              
              changed_files=$(git diff --name-only "$before_sha" "$after_sha" 2>/dev/null || true)
              
              if [ -n "$changed_files" ]; then
                # Check each changed file for potential secrets
                while IFS= read -r file; do
                  if [ -f "$file" ]; then
                    if grep -E "(AKIA|SECRET|TOKEN|KEY|PASSWORD)" "$file" >/dev/null 2>&1; then
                      echo "::error::Potential secrets found in $file"
                      exit 1
                    fi
                  fi
                done <<< "$changed_files"
              fi
            else
              echo "Initial commit detected, skipping diff check"
            fi
          fi
          
          echo "Security scan passed successfully"
