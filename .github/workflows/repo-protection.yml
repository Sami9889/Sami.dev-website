name: Enhanced Repository Protection

on:
  workflow_dispatch:
    inputs:
      action:
        description: 'Protection action to perform'
        required: true
        type: choice
        options: [lock-it-down, remove-protection, emergency-unlock, status-check]
      confirmation:
        description: 'Type "CONFIRM" to proceed (not needed for status-check)'
        required: false
        type: string
      approval_count:
        description: 'Required approvals (1-6)'
        required: true
        default: '2'
        type: choice
        options: ['1','2','3','4','5','6']
      bypass_admin:
        description: 'Allow admin bypass in emergencies?'
        required: true
        default: 'false'
        type: choice
        options: ['true','false']
      maintainer_username:
        description: 'Additional maintainer GitHub username (optional)'
        required: false
        type: string

  schedule:
    - cron: '0 2 * * *'  # Run at 2 AM UTC daily

permissions:
  contents: write
  issues: write
  pull-requests: write
  actions: read
  security-events: write

env:
  PROTECTION_LABEL: 'repo-protection-status'
  EMERGENCY_LABEL: 'ðŸš¨-emergency-unlock'

jobs:
  validate-user:
    runs-on: ubuntu-latest
    outputs:
      authorized: ${{ steps.check.outputs.authorized }}
      user_role: ${{ steps.check.outputs.user_role }}
    steps:
      - name: Validate user permissions
        id: check
        run: |
          maintainer="${{ github.event.inputs.maintainer_username }}"
          if [ "${{ github.actor }}" != "${{ github.repository_owner }}" ] && [ "${{ github.actor }}" != "$maintainer" ]; then
            echo "authorized=false" >> $GITHUB_OUTPUT
            echo "user_role=unauthorized" >> $GITHUB_OUTPUT
            exit 1
          fi
          if [ "${{ github.actor }}" == "${{ github.repository_owner }}" ]; then
            echo "user_role=owner" >> $GITHUB_OUTPUT
          else
            echo "user_role=maintainer" >> $GITHUB_OUTPUT
          fi
          echo "authorized=true" >> $GITHUB_OUTPUT

  cleanup-old-branches:
    needs: validate-user
    if: needs.validate-user.outputs.authorized == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Delete old branches
        run: |
          git fetch --prune origin
          
          # Get list of branches excluding protected ones
          branches=$(git branch -r | grep -v "HEAD\|main\|master" | sed 's/origin\///')
          
          for branch in $branches; do
            # Check if branch has no open PRs and is older than 30 days
            last_commit=$(git log -1 --format=%at origin/$branch)
            current_time=$(date +%s)
            days_old=$(( ($current_time - $last_commit) / 86400 ))
            
            if [ $days_old -gt 30 ]; then
              echo "Deleting old branch: $branch (${days_old} days old)"
              git push origin --delete $branch || true
            fi
          done

  apply-protection:
    needs: validate-user
    if: needs.validate-user.outputs.authorized == 'true' && github.event.inputs.action == 'lock-it-down'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Setup branch protection
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const approvals = parseInt('${{ github.event.inputs.approval_count }}');
            const bypassAdmin = '${{ github.event.inputs.bypass_admin }}' === 'true';
            
            for (const branch of ['main', 'master']) {
              try {
                await github.rest.repos.updateBranchProtection({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  branch: branch,
                  required_status_checks: {
                    strict: true,
                    contexts: ['security-scan']
                  },
                  enforce_admins: !bypassAdmin,
                  required_pull_request_reviews: {
                    required_approving_review_count: approvals,
                    dismiss_stale_reviews: true,
                    require_code_owner_reviews: true
                  },
                  restrictions: null,
                  allow_force_pushes: false,
                  allow_deletions: false,
                  required_conversation_resolution: true
                });
                console.log(`âœ… Protected ${branch} branch`);
              } catch (e) {
                if (e.status !== 404) {
                  throw e;
                }
                console.log(`Branch ${branch} not found, skipping`);
              }
            }

  create-security-guidelines:
    name: Post Security Guidelines
    needs: [validate-user, apply-protection]
    if: needs.validate-user.outputs.authorized == 'true' && github.event.inputs.action == 'lock-it-down'
    runs-on: ubuntu-latest
    steps:
      - name: Post security guideline issue
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const maintainer = '${{ github.event.inputs.maintainer_username }}';
            const owner = '${{ github.repository_owner }}';
            const reviewers = maintainer ? `@${owner} and @${maintainer}` : `@${owner}`;
            const approvals = '${{ github.event.inputs.approval_count }}';

            // Close any existing open security-guidelines issues first
            const { data: existing } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: ['security-guidelines'],
              state: 'open'
            });
            for (const issue of existing) {
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                state: 'closed',
                state_reason: 'completed'
              });
            }

            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: 'ðŸ”’ Security Rules & Contribution Guidelines',
              body: `# ðŸ”’ Repository Security Rules

This repository is under **strict security protection**.  

---

## âœ… Allowed
- Branch off \`main\` / \`master\`
- Open PRs for changes
- Pass **security-scan**
- Get ${approvals} approvals + code owner review
- Fix issues raised in reviews

## âŒ Forbidden
- Direct pushes to protected branches
- Merging PRs without approvals
- Merging with failing security-scan
- Merging with unresolved conversations
- Adding **forbidden files** (\`.pem\`, \`.key\`, \`.p12\`, \`.env\`, \`/secrets/\`)
- Committing secrets (tokens, API keys, passwords, private keys)
- Force pushing or deleting branches

---

âš ï¸ **PRs with forbidden files or secrets will be automatically CLOSED by the bot.**

Maintainers: ${reviewers}  
Activated by: @${{ github.actor }}  
ðŸ“Œ *This issue is pinned for contributor reference*`,
              labels: ['security-guidelines', 'documentation', 'pinned']
            });

  security-scan:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Scan for secrets and forbidden files
        run: |
          # Check for forbidden files
          forbidden_files=$(find . -type f -regex ".*\.\(pem\|key\|p12\|env\)" -o -path "*/secrets/*")
          if [ ! -z "$forbidden_files" ]; then
            echo "::error::Found forbidden files:"
            echo "$forbidden_files"
            exit 1
          fi
          
          # Check for potential secrets
          if git diff --name-only ${{ github.event.before }} ${{ github.sha }} | 
             xargs grep -l -E "(AKIA|SECRET|TOKEN|KEY|PASSWORD)" 2>/dev/null; then
            echo "::error::Potential secrets found in changes"
            exit 1
          fi
