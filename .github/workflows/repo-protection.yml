name: Professional Repository Protection

on:
  workflow_dispatch:
    inputs:
      action:
        description: "Protection action to perform"
        required: true
        type: choice
        options:
          - lock-it-down
          - remove-protection
          - emergency-unlock
          - status-check
          - audit-report
      confirmation:
        description: 'Type "CONFIRM" to proceed'
        required: false
        type: string
      approval_count:
        description: "Required approvals (1-6)"
        required: true
        default: "2"
        type: choice
        options: ["1", "2", "3", "4", "5", "6"]

  schedule:
    - cron: "0 2 * * *"
    - cron: "0 8 * * 1"

  issue_comment:
    types: [created]

  pull_request:
    types: [opened, synchronize, reopened, labeled, closed]

  pull_request_review:
    types: [submitted, dismissed]

  push:
    branches:
      - main
      - master

permissions:
  contents: write
  issues: write
  pull-requests: write
  actions: write
  checks: write
  statuses: write
  security-events: write
  id-token: write

env:
  # threshold for branch cleanup
  MAX_BRANCH_AGE_DAYS: 30
  # Exact allowed special admins — only exact names here are accepted (base name, no [bot] suffix)
  SPECIAL_ADMINS: "kinsta,getsentry,thnxdev,vercel,wasmer,coderabbit-ai,coderabbitai"
  # Explicit deny list — exact matches (either full "actor" or base name). Add "seer-by-sentry" here to block it.
  DENY_ADMINS: "seer-by-sentry,malicious-bot"
  # Useful label names
  PROTECTION_LABEL: "repo-protection-status"
  EMERGENCY_LABEL: "emergency-unlock"

jobs:
  # =========================================================
  # VALIDATE ADMIN - central authorization check used by other jobs
  # =========================================================
  validate-admin:
    runs-on: ubuntu-latest
    outputs:
      authorized: ${{ steps.check.outputs.authorized }}
      admin_name: ${{ steps.check.outputs.admin_name }}
    steps:
      - name: Check admin authorization
        id: check
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // auth logic:
            // 1) If actor equals repo owner -> authorized
            // 2) If actor or base actor (strip "[bot]") exactly matches SPECIAL_ADMINS -> authorized
            // 3) If actor or base actor exactly matches DENY_ADMINS -> denied (block)
            // 4) Fallback: check collaborator permission level (admin/maintain/write)
            const core = require('@actions/core');

            const actor = context.actor; // e.g. "alice" or "coderabbitai[bot]"
            const owner = context.repo.owner;
            const specialAdmins = (process.env.SPECIAL_ADMINS || "").split(",").map(s => s.trim()).filter(Boolean);
            const denyAdmins = (process.env.DENY_ADMINS || "").split(",").map(s => s.trim()).filter(Boolean);

            console.log("Authorisation check for actor:", actor);
            const actorBase = actor.endsWith('[bot]') ? actor.replace('[bot]', '') : actor;

            // explicit deny (full actor OR base name)
            if (denyAdmins.includes(actor) || denyAdmins.includes(actorBase)) {
              console.log("Actor explicitly denied:", actor);
              core.setOutput("authorized", "false");
              core.setOutput("admin_name", "");
              core.setFailed("Access denied (explicit blocklist).");
              return;
            }

            // repo owner immediate allow
            if (actor === owner) {
              console.log("Actor is repository owner:", owner);
              core.setOutput("authorized", "true");
              core.setOutput("admin_name", actor);
              return;
            }

            // exact match against allowed special admins (allow base or exact actor)
            if (specialAdmins.includes(actor) || specialAdmins.includes(actorBase)) {
              console.log("Actor matched SPECIAL_ADMINS:", actor);
              core.setOutput("authorized", "true");
              core.setOutput("admin_name", actor);
              return;
            }

            // fallback: check collaborator permission level
            try {
              (async () => {
                const { data: permission } = await github.rest.repos.getCollaboratorPermissionLevel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  username: actor
                });

                console.log("Collaborator permission:", permission.permission);

                if (["admin", "maintain", "write"].includes(permission.permission)) {
                  console.log("Actor has adequate collaborator permissions:", permission.permission);
                  core.setOutput("authorized", "true");
                  core.setOutput("admin_name", actor);
                  return;
                } else {
                  console.log("Actor does not have sufficient collaborator permissions:", permission.permission);
                  core.setOutput("authorized", "false");
                  core.setOutput("admin_name", "");
                  core.setFailed("Access denied. Only repository maintainers and authorized admins can execute workflows.");
                  return;
                }
              })();
            } catch (err) {
              console.log("Error checking collaborator permission:", err.message);
              core.setOutput("authorized", "false");
              core.setOutput("admin_name", "");
              core.setFailed("Access denied (permission check error).");
              return;
            }

  # =========================================================
  # CLEANUP OLD BRANCHES - scheduled run (2:00 daily)
  # =========================================================
  cleanup-old-branches:
    needs: validate-admin
    if: >
      needs.validate-admin.outputs.authorized == 'true' &&
      github.event_name == 'schedule' &&
      github.event.schedule == '0 2 * * *'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Delete stale branches
        id: cleanup
        run: |
          set -euo pipefail
          git fetch --prune origin

          branches=$(git branch -r | grep -v "HEAD\|main\|master\|develop\|staging\|production" | sed 's/origin\///' || true)
          if [ -z "$branches" ]; then
            echo "deleted_count=0" >> $GITHUB_OUTPUT
            echo "skipped_count=0" >> $GITHUB_OUTPUT
            exit 0
          fi

          deleted_count=0
          skipped_count=0

          for branch in $branches; do
            # skip empty
            if [ -z "$branch" ]; then
              continue
            fi

            if git rev-parse --verify "origin/$branch" >/dev/null 2>&1; then
              last_commit=$(git log -1 --format=%at "origin/$branch" 2>/dev/null || echo "0")
              now=$(date +%s)
              days_old=$(( (now - last_commit) / 86400 ))
              if [ $days_old -gt $MAX_BRANCH_AGE_DAYS ]; then
                echo "Deleting stale branch: $branch ($days_old days)"
                if git push origin --delete "$branch" 2>/dev/null; then
                  deleted_count=$((deleted_count + 1))
                else
                  echo "Failed to delete $branch"
                fi
              else
                skipped_count=$((skipped_count + 1))
              fi
            fi
          done

          echo "deleted_count=$deleted_count" >> $GITHUB_OUTPUT
          echo "skipped_count=$skipped_count" >> $GITHUB_OUTPUT

      - name: Post cleanup summary
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `Branch Cleanup Report - ${new Date().toISOString().split("T")[0]}`,
              body: `### Automated Branch Cleanup\n\n**Deleted:** ${{ steps.cleanup.outputs.deleted_count }}\n**Kept:** ${{ steps.cleanup.outputs.skipped_count }}\n\nThreshold: ${process.env.MAX_BRANCH_AGE_DAYS} days`,
              labels: ["automation", "branch-cleanup"]
            });

  # =========================================================
  # APPLY PROTECTION (lock-it-down)
  # =========================================================
  apply-protection:
    needs: validate-admin
    if: >
      needs.validate-admin.outputs.authorized == 'true' &&
      github.event.inputs.action == 'lock-it-down'
    runs-on: ubuntu-latest
    steps:
      - name: Require confirmation
        run: |
          if [ "${{ github.event.inputs.confirmation }}" != "CONFIRM" ]; then
            echo "::error::Confirmation required. Type CONFIRM to proceed"
            exit 1
          fi

      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Apply branch protection
        id: protect
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const approvals = parseInt("${{ github.event.inputs.approval_count }}");
            const branches = ["main", "master"];
            const protected = [];
            const failed = [];

            for (const branch of branches) {
              try {
                await github.rest.repos.updateBranchProtection({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  branch,
                  required_status_checks: {
                    strict: true,
                    contexts: ["security-scan", "vercel-check", "sentry-check"]
                  },
                  enforce_admins: true,
                  required_pull_request_reviews: {
                    required_approving_review_count: approvals,
                    dismiss_stale_reviews: true,
                    require_code_owner_reviews: true,
                    require_last_push_approval: true,
                    bypass_pull_request_allowances: {
                      users: [],
                      teams: [],
                      apps: []
                    }
                  },
                  restrictions: null,
                  required_linear_history: true,
                  allow_force_pushes: false,
                  allow_deletions: false,
                  required_conversation_resolution: true,
                  lock_branch: false,
                  allow_fork_syncing: true,
                  block_creations: false
                });

                protected.push(branch);
                console.log("Protected", branch);
              } catch (e) {
                if (e.status === 404) {
                  console.log("Branch not found:", branch);
                } else {
                  console.error("Failed to protect", branch, e.message);
                  failed.push(branch);
                }
              }
            }

            core.setOutput("protected_branches", protected.join(","));
            core.setOutput("failed_branches", failed.join(","));
            if (failed.length > 0) {
              core.setFailed("Failed to protect branches: " + failed.join(", "));
            }

  # =========================================================
  # REMOVE PROTECTION
  # =========================================================
  remove-protection:
    needs: validate-admin
    if: >
      needs.validate-admin.outputs.authorized == 'true' &&
      github.event.inputs.action == 'remove-protection'
    runs-on: ubuntu-latest
    steps:
      - name: Validate confirmation
        run: |
          if [ "${{ github.event.inputs.confirmation }}" != "CONFIRM" ]; then
            echo "::error::Confirmation required"
            exit 1
          fi

      - name: Remove protection
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            for (const branch of ["main", "master"]) {
              try {
                await github.rest.repos.deleteBranchProtection({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  branch
                });
                console.log("Removed protection from", branch);
              } catch (e) {
                if (e.status === 404) {
                  console.log("No protection on", branch);
                } else {
                  console.error("Error removing protection from", branch, e.message);
                }
              }
            }

  # =========================================================
  # EMERGENCY UNLOCK
  # =========================================================
  emergency-unlock:
    needs: validate-admin
    if: >
      needs.validate-admin.outputs.authorized == 'true' &&
      github.event.inputs.action == 'emergency-unlock'
    runs-on: ubuntu-latest
    steps:
      - name: Emergency unlock - create issue & remove protections
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const issue = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: "EMERGENCY UNLOCK - Security Override Active",
              body: `### Emergency Security Override\n\n**Activated by:** @${context.actor}\n**Time:** ${new Date().toLocaleString()}\n\nAll branch protections are being temporarily disabled. Please follow the required emergency procedures.`,
              labels: ["emergency", "security-override", "urgent"]
            });

            for (const branch of ["main", "master"]) {
              try {
                await github.rest.repos.deleteBranchProtection({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  branch
                });
                console.log("Unlocked", branch);
              } catch (e) {
                console.log("Could not unlock", branch, e.message);
              }
            }

  # =========================================================
  # STATUS CHECK - report protection state
  # =========================================================
  status-check:
    needs: validate-admin
    if: >
      needs.validate-admin.outputs.authorized == 'true' &&
      github.event.inputs.action == 'status-check'
    runs-on: ubuntu-latest
    steps:
      - name: Build status report
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            let report = `### Repository Protection Status\n\n**Generated:** ${new Date().toLocaleString()}\n**Checked by:** @${context.actor}\n\n`;
            for (const branch of ["main", "master"]) {
              try {
                const protection = await github.rest.repos.getBranchProtection({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  branch
                });

                const reviews = protection.data.required_pull_request_reviews || {};
                const checks = protection.data.required_status_checks || {};
                report += `#### Branch: ${branch}\n- Status: PROTECTED\n- Required approvals: ${reviews.required_approving_review_count || 0}\n- Code owner review: ${reviews.require_code_owner_reviews ? "YES" : "NO"}\n- Enforce for admins: ${protection.data.enforce_admins?.enabled ? "YES" : "NO"}\n- Required status checks: ${checks.contexts?.join(", ") || "None"}\n- Linear history: ${protection.data.required_linear_history?.enabled ? "YES" : "NO"}\n\n`;
              } catch (e) {
                if (e.status === 404) {
                  report += `#### Branch: ${branch}\n- Status: NOT PROTECTED\n\n`;
                } else {
                  report += `#### Branch: ${branch}\n- Status: ERROR\n- Error: ${e.message}\n\n`;
                }
              }
            }

            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `Protection Status - ${new Date().toISOString().split("T")[0]}`,
              body: report,
              labels: ["status-report", "automation"]
            });

  # =========================================================
  # AUDIT REPORT (weekly or manual)
  # =========================================================
  audit-report:
    needs: validate-admin
    if: >
      (needs.validate-admin.outputs.authorized == 'true' && github.event.inputs.action == 'audit-report') ||
      (github.event_name == 'schedule' && github.event.schedule == '0 8 * * 1')
    runs-on: ubuntu-latest
    steps:
      - name: Generate weekly audit report
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const now = new Date();
            const weekAgo = new Date();
            weekAgo.setDate(now.getDate() - 7);

            const pulls = await github.paginate(github.rest.pulls.list, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: "all",
              per_page: 100,
              sort: "updated",
              direction: "desc"
            });

            const recentPRs = pulls.filter(pr => new Date(pr.updated_at) >= weekAgo);
            const commits = await github.rest.repos.listCommits({
              owner: context.repo.owner,
              repo: context.repo.repo,
              since: weekAgo.toISOString(),
              per_page: 100
            });

            let report = `### Weekly Security Audit\n**Period:** ${weekAgo.toLocaleDateString()} - ${now.toLocaleDateString()}\n\n`;
            report += `#### Activity Summary\n- Total PRs updated: ${recentPRs.length}\n- Commits in period: ${commits.data.length}\n- PRs merged: ${recentPRs.filter(pr => pr.merged_at).length}\n- PRs open: ${recentPRs.filter(pr => pr.state === 'open').length}\n\n`;

            if (recentPRs.filter(pr => pr.merged_at).length > 0) {
              report += "#### Recent Merged PRs\n";
              recentPRs.filter(pr => pr.merged_at).slice(0, 10).forEach(pr => {
                report += `- #${pr.number}: ${pr.title} (by @${pr.merged_by?.login || "unknown"})\n`;
              });
              report += "\n";
            }

            report += `---\n**Special Admins:** ${process.env.SPECIAL_ADMINS}\n`;
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `Security Audit - ${new Date().toISOString().split("T")[0]}`,
              body: report,
              labels: ["security-audit", "weekly-report"]
            });

  # =========================================================
  # CREATE SECURITY GUIDELINES - posted after successful lock
  # =========================================================
  create-security-guidelines:
    name: Post Security Guidelines
    needs: [validate-admin, apply-protection]
    if: >
      needs.validate-admin.outputs.authorized == 'true' &&
      github.event.inputs.action == 'lock-it-down' &&
      needs.apply-protection.result == 'success'
    runs-on: ubuntu-latest
    steps:
      - name: Post security guidelines
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const approvals = "${{ github.event.inputs.approval_count }}";
            const specialAdmins = process.env.SPECIAL_ADMINS.split(",").map(a => "@" + a).join(", ");

            // close existing
            const existing = await github.rest.issues.listForRepo({
              owner: context.repo.owner, repo: context.repo.repo, labels: ["security-guidelines"], state: "open"
            });
            for (const issue of existing.data) {
              await github.rest.issues.update({ owner: context.repo.owner, repo: context.repo.repo, issue_number: issue.number, state: "closed", state_reason: "completed" });
            }

            const body = `# Repository Security Rules\n\nThis repository is under strict security protection.\n\n---\n\n## Allowed Actions\n- Create feature branches\n- Open PRs with detailed descriptions\n- Pass security-scan, vercel-check, sentry-check\n- Obtain ${approvals} approvals and code owner review\n\n## Forbidden Actions\n- Direct pushes to protected branches\n- Merging without required approvals\n- Adding forbidden files (.pem, .key, .p12, .env, /secrets/)\n\n**Special Admins:** ${specialAdmins}\n**Activated by:** @${context.actor}\n**Date:** ${new Date().toLocaleString()}\n`;

            const newIssue = await github.rest.issues.create({
              owner: context.repo.owner, repo: context.repo.repo,
              title: "LOCKDOWN: Repository Security Rules",
              body,
              labels: ["security-guidelines", "documentation", "pinned"]
            });

            console.log("Created guidelines issue #", newIssue.data.number);

  # =========================================================
  # SECURITY SCAN - PR-triggered
  # =========================================================
  security-scan:
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    steps:
      - name: Checkout PR
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run security scan
        id: scan
        continue-on-error: true
        run: |
          set -euo pipefail
          echo "Starting security scan..."

          base_sha="${{ github.event.pull_request.base.sha }}"
          head_sha="${{ github.event.pull_request.head.sha }}"

          changed_files=$(git diff --name-only "$base_sha" "$head_sha" 2>/dev/null || true)
          if [ -z "$changed_files" ]; then
            echo "scan_result=passed" >> $GITHUB_OUTPUT
            echo "scan_details=No files changed" >> $GITHUB_OUTPUT
            exit 0
          fi

          forbidden_count=0
          secret_count=0
          warning_count=0
          findings=""

          while IFS= read -r file; do
            [ -f "$file" ] || continue

            case "$file" in
              *.pem|*.key|*.p12|*.pfx|*.keystore|id_rsa|id_dsa|id_ecdsa|id_ed25519)
                findings="${findings}FORBIDDEN: Private key or certificate: $file\n"
                forbidden_count=$((forbidden_count + 1));;
              *.env|*.env.*|.env.*)
                findings="${findings}FORBIDDEN: Environment file: $file\n"
                forbidden_count=$((forbidden_count + 1));;
              */secrets/*|*/.secrets/*)
                findings="${findings}FORBIDDEN: File in secrets directory: $file\n"
                forbidden_count=$((forbidden_count + 1));;
            esac

            # skip .github config files from secret detection
            if [[ "$file" == .github/* ]]; then
              continue
            fi

            if grep -qE "AKIA[0-9A-Z]{16}" "$file" 2>/dev/null; then
              findings="${findings}SECRET: AWS key in $file\n"
              secret_count=$((secret_count + 1))
            fi

            if grep -qE "(ghp_|gho_|ghu_|ghs_|ghr_)[a-zA-Z0-9]{36,}" "$file" 2>/dev/null; then
              findings="${findings}SECRET: GitHub token in $file\n"
              secret_count=$((secret_count + 1))
            fi

            if grep -qE "sk-[a-zA-Z0-9]{48}" "$file" 2>/dev/null; then
              findings="${findings}SECRET: OpenAI key in $file\n"
              secret_count=$((secret_count + 1))
            fi

            if grep -qE "vercel_[a-zA-Z0-9]{24}" "$file" 2>/dev/null; then
              findings="${findings}SECRET: Vercel token in $file\n"
              secret_count=$((secret_count + 1))
            fi

            if grep -qE "https://[a-z0-9]+@[a-z0-9]+\.ingest\.sentry\.io/[0-9]+" "$file" 2>/dev/null; then
              findings="${findings}WARNING: Sentry DSN in $file\n"
              warning_count=$((warning_count + 1))
            fi

            if grep -qE "(api[_-]?key|apikey|api[_-]?secret)['\"]?\s*[:=]\s*['\"][a-zA-Z0-9]{20,}" "$file" 2>/dev/null; then
              findings="${findings}WARNING: Potential API key in $file\n"
              warning_count=$((warning_count + 1))
            fi

            if grep -q "BEGIN.*PRIVATE KEY" "$file" 2>/dev/null; then
              findings="${findings}SECRET: Private key content in $file\n"
              secret_count=$((secret_count + 1))
            fi

            if grep -qE "(password|passwd|pwd)['\"]?\s*[:=]\s*['\"][^'\"]{8,}" "$file" 2>/dev/null; then
              findings="${findings}WARNING: Potential password in $file\n"
              warning_count=$((warning_count + 1))
            fi

            if grep -qE "(mongodb|postgres|mysql)://[^'\"\s]+" "$file" 2>/dev/null; then
              findings="${findings}SECRET: Database connection string in $file\n"
              secret_count=$((secret_count + 1))
            fi

          done <<< "$changed_files"

          # write outputs
          if [ $forbidden_count -gt 0 ] || [ $secret_count -gt 0 ]; then
            echo "scan_result=failed" >> $GITHUB_OUTPUT
            echo "scan_details=$findings" >> $GITHUB_OUTPUT
            echo "forbidden_count=$forbidden_count" >> $GITHUB_OUTPUT
            echo "secret_count=$secret_count" >> $GITHUB_OUTPUT
            echo "Security scan FAILED"
            exit 1
          elif [ $warning_count -gt 0 ]; then
            echo "scan_result=warning" >> $GITHUB_OUTPUT
            echo "scan_details=$findings" >> $GITHUB_OUTPUT
            echo "warning_count=$warning_count" >> $GITHUB_OUTPUT
            echo "Security scan: warnings"
          else
            echo "scan_result=passed" >> $GITHUB_OUTPUT
            echo "scan_details=All checks passed" >> $GITHUB_OUTPUT
            echo "Security scan PASSED"
          fi

      - name: Comment scan results
        if: always()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const scanResult = "${{ steps.scan.outputs.scan_result }}";
            const scanDetails = `${{ steps.scan.outputs.scan_details }}` || "";
            const prNumber = context.issue.number;
            let body = "";

            if (scanResult === "passed") {
              body = "### Security Scan Results\n\n**Status:** PASSED\n\nAll checks passed.\n";
            } else if (scanResult === "warning") {
              body = "### Security Scan Results\n\n**Status:** WARNING\n\n```\n" + scanDetails + "\n```\n\nPlease review these warnings.";
            } else if (scanResult === "failed") {
              const forbidden = "${{ steps.scan.outputs.forbidden_count }}" || "0";
              const secrets = "${{ steps.scan.outputs.secret_count }}" || "0";
              body = "### Security Scan Results\n\n**Status:** FAILED\n\n**Forbidden:** " + forbidden + "\n**Secrets:** " + secrets + "\n\n```\n" + scanDetails + "\n```\n\nThis PR cannot be merged until resolved.";
            } else {
              body = "### Security Scan Results\n\n**Status:** PASSED (no changes to scan)";
            }

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body
            });

  # =========================================================
  # BOT COMMAND HANDLER (issue comments on PRs)
  # =========================================================
  bot-command-handler:
    name: Handle Bot Commands
    runs-on: ubuntu-latest
    if: >
      github.event_name == 'issue_comment' &&
      github.event.issue.pull_request == true
    steps:
      - name: Check admin authorization (bot)
        id: auth_check
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const core = require('@actions/core');
            const actor = context.payload.comment.user.login;
            const owner = context.repo.owner;
            const specialAdmins = (process.env.SPECIAL_ADMINS || "").split(",").map(s => s.trim()).filter(Boolean);
            const denyAdmins = (process.env.DENY_ADMINS || "").split(",").map(s => s.trim()).filter(Boolean);
            const actorBase = actor.endsWith("[bot]") ? actor.replace("[bot]","") : actor;

            // explicit deny
            if (denyAdmins.includes(actor) || denyAdmins.includes(actorBase)) {
              core.setOutput("authorized", "false");
              core.setOutput("commenter", actor);
              core.setFailed("Actor explicitly denied");
              return;
            }

            // owner
            if (actor === owner) {
              core.setOutput("authorized", "true");
              core.setOutput("commenter", actor);
              return;
            }

            // exact special admin match
            if (specialAdmins.includes(actor) || specialAdmins.includes(actorBase)) {
              core.setOutput("authorized", "true");
              core.setOutput("commenter", actor);
              return;
            }

            // fallback permission check
            try {
              (async () => {
                const { data: permission } = await github.rest.repos.getCollaboratorPermissionLevel({
                  owner: context.repo.owner, repo: context.repo.repo, username: actor
                });

                if (["admin","maintain","write"].includes(permission.permission)) {
                  core.setOutput("authorized", "true");
                  core.setOutput("commenter", actor);
                  return;
                } else {
                  core.setOutput("authorized", "false");
                  core.setOutput("commenter", actor);
                  core.setFailed("Not authorized");
                  return;
                }
              })();
            } catch (err) {
              core.setOutput("authorized", "false");
              core.setOutput("commenter", actor);
              core.setFailed("Permission check error");
            }

      - name: Process bot command
        if: steps.auth_check.outputs.authorized == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const comment = context.payload.comment.body.trim();
            const commenter = "${{ steps.auth_check.outputs.commenter }}";
            const prNumber = context.issue.number;

            // normalize command
            const cmd = comment.toLowerCase();

            if (cmd.startsWith("/bot approve")) {
              await github.rest.issues.createComment({
                owner: context.repo.owner, repo: context.repo.repo, issue_number: prNumber,
                body: `### PR Approved\nApproved by: @${commenter}\nStatus: APPROVED`
              });
              await github.rest.issues.addLabels({ owner: context.repo.owner, repo: context.repo.repo, issue_number: prNumber, labels: ["approved","ready-to-merge"] });

            } else if (cmd.startsWith("/bot reject")) {
              const reason = comment.replace("/bot reject","").trim() || "No reason provided";
              await github.rest.issues.createComment({
                owner: context.repo.owner, repo: context.repo.repo, issue_number: prNumber,
                body: `### PR Rejected\nRejected by: @${commenter}\nReason: ${reason}\nStatus: CHANGES REQUESTED`
              });
              await github.rest.issues.addLabels({ owner: context.repo.owner, repo: context.repo.repo, issue_number: prNumber, labels: ["changes-requested"] });

            } else if (cmd.startsWith("/bot status")) {
              const pr = await github.rest.pulls.get({ owner: context.repo.owner, repo: context.repo.repo, pull_number: prNumber });
              const reviews = await github.rest.pulls.listReviews({ owner: context.repo.owner, repo: context.repo.repo, pull_number: prNumber });
              const approvals = reviews.data.filter(r => r.state === "APPROVED").length;
              await github.rest.issues.createComment({
                owner: context.repo.owner, repo: context.repo.repo, issue_number: prNumber,
                body: `### PR Status\n**Approvals:** ${approvals}\n**Mergeable:** ${pr.data.mergeable ? "YES" : "NO"}\nRequested by: @${commenter}`
              });

            } else if (cmd.startsWith("/bot")) {
              await github.rest.issues.createComment({
                owner: context.repo.owner, repo: context.repo.repo, issue_number: prNumber,
                body: "Unknown /bot command. Available: `/bot approve`, `/bot reject [reason]`, `/bot status`"
              });
            }

      - name: Unauthorized command reply
        if: steps.auth_check.outputs.authorized == 'false'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const comment = context.payload.comment.body.trim();
            if (comment.toLowerCase().startsWith("/bot")) {
              await github.rest.issues.createComment({
                owner: context.repo.owner, repo: context.repo.repo, issue_number: context.issue.number,
                body: "Only authorized admins and maintainers can use bot commands.\nSpecial admins: " + process.env.SPECIAL_ADMINS
              });
            }
