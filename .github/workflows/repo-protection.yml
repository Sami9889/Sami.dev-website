name: Professional Repository Protection

on:
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        required: true
        type: choice
        options: 
          - lock-it-down
          - remove-protection
          - emergency-unlock
          - status-check
          - audit-report
          - admin-console
          - security-health-check
          - compliance-report
      confirmation:
        description: 'Type "CONFIRM" to proceed'
        required: false
        type: string
      approval_count:
        description: 'Required approvals (1-6)'
        required: true
        default: '2'
        type: choice
        options: ['1','2','3','4','5','6']
      notification_level:
        description: 'Security notification level'
        required: false
        default: 'normal'
        type: choice
        options: ['silent','normal','verbose']

  schedule:
    - cron: '0 2 * * *'      # Daily cleanup at 2 AM UTC
    - cron: '0 8 * * 1'      # Weekly audit every Monday at 8 AM UTC
    - cron: '0 12 * * 0'     # Weekly compliance report Sunday noon
    - cron: '0 */6 * * *'    # Security health check every 6 hours

  issue_comment:
    types: [created]

  pull_request:
    types: [opened, synchronize, reopened, labeled, closed, ready_for_review]

  pull_request_review:
    types: [submitted, dismissed, edited]

  push:
    branches:
      - main
      - master
      - develop
      - staging
      - production

  workflow_run:
    workflows: ["*"]
    types: [completed]

# NOTE: This workflow requires a GitHub token with admin permissions.
# The GITHUB_TOKEN has limitations - for branch protection, you need either:
# 1. Repository admin permissions on the token
# 2. A Personal Access Token (PAT) with 'repo' scope stored as a secret
# 3. A GitHub App with repository administration permissions

permissions:
  contents: write
  issues: write
  pull-requests: write
  actions: write
  checks: write
  statuses: write
  security-events: write
  id-token: write

env:
  MAX_BRANCH_AGE_DAYS: 30
  STALE_BRANCH_WARNING_DAYS: 21
  SPECIAL_ADMINS: 'kinsta,getsentry,thnxdev,vercel,wasmer,coderabbit-ai,coderabbitai[bot],dependabot[bot],renovate[bot],github-actions[bot],slack[bot]'
  PROTECTED_BRANCHES: 'main,master,develop,staging,production'
  SECURITY_SCAN_VERSION: 'v2.1.0'

jobs:
  validate-user:
    runs-on: ubuntu-latest
    outputs:
      authorized: ${{ steps.check.outputs.authorized }}
      user_role: ${{ steps.check.outputs.user_role }}
      user_name: ${{ steps.check.outputs.user_name }}
      can_lockdown: ${{ steps.check.outputs.can_lockdown }}
      can_emergency: ${{ steps.check.outputs.can_emergency }}
      can_remove_protection: ${{ steps.check.outputs.can_remove_protection }}
    steps:
      - name: Check user permissions and role
        id: check
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const actor = context.actor;
            const owner = context.repo.owner;
            const specialAdmins = process.env.SPECIAL_ADMINS.split(',');
            
            console.log('===== AUTHORIZATION CHECK =====');
            console.log('User: ' + actor);
            console.log('Repository: ' + context.repo.owner + '/' + context.repo.repo);
            
            let userRole = 'unauthorized';
            let canLockdown = false;
            let canEmergency = false;
            let canRemoveProtection = false;
            
            // Check if user is repository owner - SUPER ADMIN (always authorized)
            if (actor === owner) {
              console.log('Role: SUPER ADMIN (Repository Owner)');
              userRole = 'super_admin';
              canLockdown = true;
              canEmergency = true;
              canRemoveProtection = true;
              core.setOutput('authorized', 'true');
              core.setOutput('user_role', userRole);
              core.setOutput('user_name', actor);
              core.setOutput('can_lockdown', 'true');
              core.setOutput('can_emergency', 'true');
              core.setOutput('can_remove_protection', 'true');
              return;
            }
            
            // Check if actor is a bot account - ALL BOTS GET SPECIAL ADMIN ACCESS
            if (actor.endsWith('[bot]')) {
              console.log('Role: BOT ACCOUNT - AUTHORIZED');
              
              // Check if it's a whitelisted bot
              const baseName = actor.replace('[bot]', '');
              const isWhitelisted = specialAdmins.includes(baseName) || specialAdmins.includes(actor);
              
              if (isWhitelisted) {
                console.log('Bot is whitelisted: ' + actor);
                userRole = 'special_admin';
                canLockdown = true;
                canEmergency = false;
                canRemoveProtection = false;
              } else {
                console.log('Bot is not whitelisted but authorized for basic operations: ' + actor);
                userRole = 'bot';
                canLockdown = false;
                canEmergency = false;
                canRemoveProtection = false;
              }
              
              core.setOutput('authorized', 'true');
              core.setOutput('user_role', userRole);
              core.setOutput('user_name', actor);
              core.setOutput('can_lockdown', canLockdown.toString());
              core.setOutput('can_emergency', 'false');
              core.setOutput('can_remove_protection', canRemoveProtection.toString());
              return;
            }
            
            // Check if user is in special admins list - SPECIAL ADMIN
            if (specialAdmins.includes(actor)) {
              console.log('Role: SPECIAL ADMIN');
              userRole = 'special_admin';
              canLockdown = true;
              canEmergency = false;
              canRemoveProtection = false;
              core.setOutput('authorized', 'true');
              core.setOutput('user_role', userRole);
              core.setOutput('user_name', actor);
              core.setOutput('can_lockdown', 'true');
              core.setOutput('can_emergency', 'false');
              core.setOutput('can_remove_protection', 'false');
              return;
            }
            
            // Check repository permissions - MAINTAINER/ADMIN/WRITE
            try {
              const { data: permission } = await github.rest.repos.getCollaboratorPermissionLevel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                username: actor
              });
              
              const userPermission = permission.permission;
              console.log('Permission level: ' + userPermission);
              
              if (userPermission === 'admin') {
                console.log('Role: ADMIN');
                userRole = 'admin';
                canLockdown = true;
                canEmergency = false;
                canRemoveProtection = true;
                core.setOutput('authorized', 'true');
                core.setOutput('user_role', userRole);
                core.setOutput('user_name', actor);
                core.setOutput('can_lockdown', 'true');
                core.setOutput('can_emergency', 'false');
                core.setOutput('can_remove_protection', 'true');
                return;
              } else if (userPermission === 'maintain') {
                console.log('Role: MAINTAINER');
                userRole = 'maintainer';
                canLockdown = false;
                canEmergency = false;
                canRemoveProtection = false;
                core.setOutput('authorized', 'true');
                core.setOutput('user_role', userRole);
                core.setOutput('user_name', actor);
                core.setOutput('can_lockdown', 'false');
                core.setOutput('can_emergency', 'false');
                core.setOutput('can_remove_protection', 'false');
                return;
              } else if (userPermission === 'write') {
                console.log('Role: CONTRIBUTOR');
                userRole = 'contributor';
                canLockdown = false;
                canEmergency = false;
                canRemoveProtection = false;
                core.setOutput('authorized', 'true');
                core.setOutput('user_role', userRole);
                core.setOutput('user_name', actor);
                core.setOutput('can_lockdown', 'false');
                core.setOutput('can_emergency', 'false');
                core.setOutput('can_remove_protection', 'false');
                return;
              }
            } catch (error) {
              console.log('Could not check user permissions: ' + error.message);
              console.log('This may be a bot account or app installation');
            }
            
            // User is not authorized
            console.log('Role: UNAUTHORIZED');
            console.log('Actor "' + actor + '" does not match owner "' + owner + '"');
            console.log('Actor is not in special admins list');
            console.log('No repository permissions found');
            core.setOutput('authorized', 'false');
            core.setOutput('user_role', 'unauthorized');
            core.setOutput('user_name', actor);
            core.setOutput('can_lockdown', 'false');
            core.setOutput('can_emergency', 'false');
            core.setOutput('can_remove_protection', 'false');
            core.setFailed('Access denied. User: ' + actor + ', Owner: ' + owner);

  admin-console:
    needs: validate-user
    if: |
      needs.validate-user.outputs.authorized == 'true' &&
      github.event.inputs.action == 'admin-console'
    runs-on: ubuntu-latest
    steps:
      - name: Generate admin console dashboard
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const userName = '${{ needs.validate-user.outputs.user_name }}';
            const userRole = '${{ needs.validate-user.outputs.user_role }}';
            const canLockdown = '${{ needs.validate-user.outputs.can_lockdown }}' === 'true';
            const canEmergency = '${{ needs.validate-user.outputs.can_emergency }}' === 'true';
            const canRemoveProtection = '${{ needs.validate-user.outputs.can_remove_protection }}' === 'true';
            
            // Get current protection status
            let protectionStatus = {};
            for (const branch of ['main', 'master']) {
              try {
                const protection = await github.rest.repos.getBranchProtection({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  branch: branch
                });
                protectionStatus[branch] = {
                  protected: true,
                  approvals: protection.data.required_pull_request_reviews?.required_approving_review_count || 0,
                  enforceAdmins: protection.data.enforce_admins?.enabled || false,
                  requiredChecks: protection.data.required_status_checks?.contexts || []
                };
              } catch (e) {
                protectionStatus[branch] = { protected: false };
              }
            }
            
            // Get recent activity
            const weekAgo = new Date();
            weekAgo.setDate(weekAgo.getDate() - 7);
            
            const prs = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'all',
              per_page: 10,
              sort: 'updated',
              direction: 'desc'
            });
            
            const recentPRs = prs.data.filter(pr => new Date(pr.updated_at) >= weekAgo);
            
            // Build dashboard
            let dashboard = '# Admin Console Dashboard\n\n';
            dashboard += `**Generated:** ${new Date().toLocaleString()}\n`;
            dashboard += `**User:** @${userName}\n`;
            dashboard += `**Role:** ${userRole.toUpperCase().replace('_', ' ')}\n\n`;
            
            dashboard += '---\n\n';
            
            // Role capabilities
            dashboard += '## Your Permissions\n\n';
            
            const roleDescriptions = {
              'super_admin': 'Full control over repository protection and settings',
              'admin': 'Can manage branch protection and repository settings',
              'special_admin': 'Authorized external admin (limited emergency access)',
              'maintainer': 'Can approve PRs and manage issues',
              'contributor': 'Can create PRs and comment'
            };
            
            dashboard += `**Description:** ${roleDescriptions[userRole] || 'Limited access'}\n\n`;
            
            dashboard += '**Capabilities:**\n';
            dashboard += `- Lock down repository: ${canLockdown ? 'YES' : 'NO'}\n`;
            dashboard += `- Remove protection: ${canRemoveProtection ? 'YES' : 'NO'}\n`;
            dashboard += `- Emergency unlock: ${canEmergency ? 'YES' : 'NO'}\n`;
            dashboard += `- View status: YES\n`;
            dashboard += `- Approve PRs: YES\n`;
            dashboard += `- Run audits: YES\n\n`;
            
            dashboard += '---\n\n';
            
            // Current protection status
            dashboard += '## Current Protection Status\n\n';
            
            for (const [branch, status] of Object.entries(protectionStatus)) {
              if (status.protected) {
                dashboard += `### Branch: \`${branch}\` - PROTECTED\n\n`;
                dashboard += `- Required approvals: ${status.approvals}\n`;
                dashboard += `- Enforce for admins: ${status.enforceAdmins ? 'YES' : 'NO'}\n`;
                dashboard += `- Required checks: ${status.requiredChecks.join(', ') || 'None'}\n\n`;
              } else {
                dashboard += `### Branch: \`${branch}\` - NOT PROTECTED\n\n`;
              }
            }
            
            dashboard += '---\n\n';
            
            // Recent activity
            dashboard += '## Recent Activity (Last 7 Days)\n\n';
            dashboard += `- Total PRs: ${recentPRs.length}\n`;
            dashboard += `- Open PRs: ${recentPRs.filter(pr => pr.state === 'open').length}\n`;
            dashboard += `- Merged PRs: ${recentPRs.filter(pr => pr.merged_at).length}\n`;
            dashboard += `- Closed PRs: ${recentPRs.filter(pr => pr.state === 'closed' && !pr.merged_at).length}\n\n`;
            
            if (recentPRs.length > 0) {
              dashboard += '**Recent Pull Requests:**\n\n';
              recentPRs.slice(0, 5).forEach(pr => {
                const status = pr.state === 'open' ? 'OPEN' : pr.merged_at ? 'MERGED' : 'CLOSED';
                dashboard += `- #${pr.number}: ${pr.title} [${status}]\n`;
              });
              dashboard += '\n';
            }
            
            dashboard += '---\n\n';
            
            // Available actions
            dashboard += '## Available Actions\n\n';
            
            if (canLockdown) {
              dashboard += '### Lock Down Repository\n';
              dashboard += 'Apply strict branch protection rules.\n';
              dashboard += '```\nAction: lock-it-down\nConfirmation: CONFIRM\n```\n\n';
            }
            
            if (canRemoveProtection) {
              dashboard += '### Remove Protection\n';
              dashboard += 'Remove branch protection rules.\n';
              dashboard += '```\nAction: remove-protection\nConfirmation: CONFIRM\n```\n\n';
            }
            
            if (canEmergency) {
              dashboard += '### Emergency Unlock\n';
              dashboard += 'EMERGENCY ONLY - Temporarily disable all protections.\n';
              dashboard += '```\nAction: emergency-unlock\nConfirmation: CONFIRM\n```\n\n';
            }
            
            dashboard += '### Status Check\n';
            dashboard += 'View detailed protection status.\n';
            dashboard += '```\nAction: status-check\n```\n\n';
            
            dashboard += '### Security Audit\n';
            dashboard += 'Generate comprehensive security audit report.\n';
            dashboard += '```\nAction: audit-report\n```\n\n';
            
            dashboard += '---\n\n';
            
            // Bot commands
            dashboard += '## Bot Commands (In PR Comments)\n\n';
            dashboard += '- `/bot approve` - Approve a pull request\n';
            dashboard += '- `/bot reject [reason]` - Reject a pull request\n';
            dashboard += '- `/bot status` - Check PR status\n\n';
            
            dashboard += '---\n\n';
            
            // Role hierarchy
            dashboard += '## Role Hierarchy\n\n';
            dashboard += '1. **SUPER ADMIN** (Repository Owner) - Full access to all features\n';
            dashboard += '2. **ADMIN** (Admin permission) - Can manage protection, no emergency access\n';
            dashboard += '3. **SPECIAL ADMIN** (External services) - Can apply protection only\n';
            dashboard += '4. **MAINTAINER** (Maintain permission) - Can approve PRs, view status\n';
            dashboard += '5. **CONTRIBUTOR** (Write permission) - Can create PRs, limited access\n\n';
            
            dashboard += `**Your current role: ${userRole.toUpperCase().replace('_', ' ')}**\n\n`;
            
            dashboard += '---\n\n';
            dashboard += '*Generated by Professional Repository Protection System*';
            
            // Create issue with dashboard
            const issue = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `Admin Console - ${userName} - ${new Date().toISOString().split('T')[0]}`,
              body: dashboard,
              labels: ['admin-console', 'documentation']
            });
            
            console.log('Admin console dashboard created: #' + issue.data.number);

  cleanup-old-branches:
    needs: validate-user
    if: needs.validate-user.outputs.authorized == 'true' && github.event_name == 'schedule' && github.event.schedule == '0 2 * * *'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Delete stale branches
        id: cleanup
        run: |
          echo "Branch cleanup starting..."
          git fetch --prune origin

          branches=$(git branch -r | grep -v "HEAD\|main\|master\|develop\|staging\|production" | sed 's/origin\///' || true)

          if [ -z "$branches" ]; then
            echo "No branches to process"
            echo "deleted_count=0" >> $GITHUB_OUTPUT
            echo "skipped_count=0" >> $GITHUB_OUTPUT
            exit 0
          fi

          deleted_count=0
          skipped_count=0
          
          echo "$branches" | while IFS= read -r branch; do
            branch=$(echo "$branch" | xargs)

            if [ -z "$branch" ]; then
              continue
            fi

            if git rev-parse --verify "origin/$branch" >/dev/null 2>&1; then
              last_commit=$(git log -1 --format=%at "origin/$branch" 2>/dev/null || echo "0")
              current_time=$(date +%s)
              days_old=$(( ($current_time - $last_commit) / 86400 ))

              if [ $days_old -gt ${{ env.MAX_BRANCH_AGE_DAYS }} ]; then
                echo "Deleting stale branch: $branch (${days_old} days old)"
                if git push origin --delete "$branch" 2>/dev/null; then
                  deleted_count=$((deleted_count + 1))
                else
                  echo "Failed to delete $branch"
                fi
              else
                skipped_count=$((skipped_count + 1))
              fi
            fi
          done

          echo "deleted_count=$deleted_count" >> $GITHUB_OUTPUT
          echo "skipped_count=$skipped_count" >> $GITHUB_OUTPUT

      - name: Post cleanup summary
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const deleted = '${{ steps.cleanup.outputs.deleted_count }}' || '0';
            const skipped = '${{ steps.cleanup.outputs.skipped_count }}' || '0';
            
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `Branch Cleanup Report - ${new Date().toISOString().split('T')[0]}`,
              body: `### Automated Branch Cleanup\n\n` +
                    `**Date:** ${new Date().toLocaleString()}\n\n` +
                    `**Statistics:**\n` +
                    `- Branches deleted: ${deleted}\n` +
                    `- Branches kept: ${skipped}\n` +
                    `- Cleanup threshold: ${process.env.MAX_BRANCH_AGE_DAYS} days\n\n` +
                    `Stale branches older than ${process.env.MAX_BRANCH_AGE_DAYS} days were removed.\n` +
                    `Protected branches are never deleted.`,
              labels: ['automation', 'maintenance', 'branch-cleanup']
            });

  apply-protection:
    needs: validate-user
    if: |
      needs.validate-user.outputs.authorized == 'true' &&
      needs.validate-user.outputs.can_lockdown == 'true' &&
      github.event.inputs.action == 'lock-it-down'
    runs-on: ubuntu-latest
    steps:
      - name: Validate confirmation
        run: |
          if [ "${{ github.event.inputs.confirmation }}" != "CONFIRM" ]; then
            echo "::error::Confirmation required"
            exit 1
          fi

      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Apply branch protection rules
        id: protect
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const approvals = parseInt('${{ github.event.inputs.approval_count }}');

            console.log('Applying branch protection...');
            console.log('Required approvals: ' + approvals);

            const protectedBranches = [];
            const failedBranches = [];

            for (const branch of ['main', 'master']) {
              try {
                await github.rest.repos.updateBranchProtection({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  branch: branch,
                  required_status_checks: {
                    strict: true,
                    contexts: ['security-scan', 'vercel-check', 'sentry-check']
                  },
                  enforce_admins: true,
                  required_pull_request_reviews: {
                    required_approving_review_count: approvals,
                    dismiss_stale_reviews: true,
                    require_code_owner_reviews: true,
                    require_last_push_approval: true,
                    bypass_pull_request_allowances: {
                      users: [],
                      teams: [],
                      apps: []
                    }
                  },
                  restrictions: null,
                  required_linear_history: true,
                  allow_force_pushes: false,
                  allow_deletions: false,
                  required_conversation_resolution: true,
                  lock_branch: false,
                  allow_fork_syncing: true,
                  block_creations: false
                });
                
                console.log('Protected ' + branch + ' branch');
                protectedBranches.push(branch);
                
              } catch (e) {
                if (e.status === 404) {
                  console.log('Branch ' + branch + ' not found');
                } else {
                  console.error('Failed to protect ' + branch + ': ' + e.message);
                  failedBranches.push(branch);
                }
              }
            }

            core.setOutput('protected_branches', protectedBranches.join(','));
            core.setOutput('failed_branches', failedBranches.join(','));
            
            if (failedBranches.length > 0) {
              core.setFailed('Failed to protect branches: ' + failedBranches.join(', '));
            }

  remove-protection:
    needs: validate-user
    if: |
      needs.validate-user.outputs.authorized == 'true' &&
      needs.validate-user.outputs.can_remove_protection == 'true' &&
      github.event.inputs.action == 'remove-protection'
    runs-on: ubuntu-latest
    steps:
      - name: Validate confirmation
        run: |
          if [ "${{ github.event.inputs.confirmation }}" != "CONFIRM" ]; then
            echo "::error::Confirmation required"
            exit 1
          fi

      - name: Remove branch protection
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            console.log('Removing branch protection...');

            for (const branch of ['main', 'master']) {
              try {
                await github.rest.repos.deleteBranchProtection({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  branch: branch
                });
                console.log('Removed protection from ' + branch);
              } catch (e) {
                if (e.status === 404) {
                  console.log('No protection found on ' + branch);
                } else {
                  console.error('Failed to remove protection from ' + branch + ': ' + e.message);
                }
              }
            }

  emergency-unlock:
    needs: validate-user
    if: |
      needs.validate-user.outputs.authorized == 'true' &&
      needs.validate-user.outputs.can_emergency == 'true' &&
      github.event.inputs.action == 'emergency-unlock'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Scan for secrets and forbidden files
        run: |
          echo "Starting security scan on PR changes only..."
          
          # Get the base branch
          base_sha="${{ github.event.pull_request.base.sha }}"
          head_sha="${{ github.event.pull_request.head.sha }}"
          
          echo "Scanning changes between $base_sha and $head_sha"
          
          # Get only the files changed in this PR
          changed_files=$(git diff --name-only "$base_sha" "$head_sha" 2>/dev/null || true)
          
          if [ -z "$changed_files" ]; then
            echo "No files changed in this PR"
            exit 0
          fi
          
          echo "Files changed in this PR:"
          echo "$changed_files"
          echo ""
          
          # Check for forbidden file types in PR changes only
          forbidden_found=""
          while IFS= read -r file; do
            if [ -f "$file" ]; then
              case "$file" in
                *.pem|*.key|*.p12|*.env)
                  echo "::error::Forbidden file type: $file"
                  forbidden_found="true"
                  ;;
                */secrets/*)
                  echo "::error::File in forbidden directory: $file"
                  forbidden_found="true"
                  ;;
              esac
            fi
          done <<< "$changed_files"
          
          if [ -n "$forbidden_found" ]; then
            echo "::error::Forbidden files detected in PR"
            exit 1
          fi
          
          echo "No forbidden files found in PR changes"
          
          # Check for potential secrets in changed files only
          secrets_found=""
          while IFS= read -r file; do
            if [ -f "$file" ]; then
              # Skip workflow files and config files in .github
              if [[ "$file" == .github/* ]]; then
                echo "Skipping repository file: $file"
                continue
              fi
              
              # Check for secrets
              if grep -l -E "(AKIA[0-9A-Z]{16}|ghp_[a-zA-Z0-9]{36}|gho_[a-zA-Z0-9]{36}|github_pat_[a-zA-Z0-9]{22}_[a-zA-Z0-9]{59})" "$file" >/dev/null 2>&1; then
                echo "::error::Potential AWS or GitHub secrets found in: $file"
                secrets_found="true"
              elif grep -l -E "(sk-[a-zA-Z0-9]{48}|api[_-]?key['\"]?\s*[:=]\s*['\"][a-zA-Z0-9]{32,})" "$file" >/dev/null 2>&1; then
                echo "::error::Potential API keys found in: $file"
                secrets_found="true"
              elif grep -l -E "(password['\"]?\s*[:=]\s*['\"][^'\"]{8,}|passwd['\"]?\s*[:=]\s*['\"][^'\"]{8,})" "$file" >/dev/null 2>&1; then
                echo "::error::Potential passwords found in: $file"
                secrets_found="true"
              fi
            fi
          done <<< "$changed_files"
          
          if [ -n "$secrets_found" ]; then
            echo "::error::Potential secrets detected in PR"
            exit 1
          fi
          
          echo "Security scan passed successfully"
      
      - name: Comment on PR with scan results
        if: github.event_name == 'pull_request' && always()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            console.log('EMERGENCY UNLOCK INITIATED');
            
            const issue = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: 'EMERGENCY UNLOCK - Security Override Active',
              body: `### Emergency Security Override\n\n` +
                    `**Activated by:** @${context.actor}\n` +
                    `**Time:** ${new Date().toLocaleString()}\n\n` +
                    `All branch protections have been temporarily disabled.\n\n` +
                    `**Required Actions:**\n` +
                    `1. Complete emergency changes\n` +
                    `2. Document all modifications\n` +
                    `3. Re-enable protection immediately\n` +
                    `4. Close this issue when complete`,
              labels: ['emergency', 'security-override', 'urgent']
            });

            for (const branch of ['main', 'master']) {
              try {
                await github.rest.repos.deleteBranchProtection({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  branch: branch
                });
                console.log('Emergency unlock: ' + branch);
              } catch (e) {
                console.log(branch + ': ' + e.message);
              }
            }

  status-check:
    needs: validate-user
    if: |
      needs.validate-user.outputs.authorized == 'true' &&
      github.event.inputs.action == 'status-check'
    runs-on: ubuntu-latest
    steps:
      - name: Check protection status
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            console.log('Checking repository protection status...\n');
            
            let statusReport = '### Repository Protection Status\n\n';
            statusReport += `**Generated:** ${new Date().toLocaleString()}\n`;
            statusReport += `**Checked by:** @${context.actor}\n`;
            statusReport += `**Role:** ${needs.validate-user.outputs.user_role}\n\n`;

            // Get repository info first
            const repo = await github.rest.repos.get({
              owner: context.repo.owner,
              repo: context.repo.repo
            });

            const protectedBranches = process.env.PROTECTED_BRANCHES.split(',');
            
            for (const branchName of protectedBranches) {
              try {
                // First check if branch exists
                const branch = await github.rest.repos.getBranch({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  branch: branchName
                });

                statusReport += `#### Branch: \`${branchName}\` âœ…\n\n`;
                statusReport += `**Branch exists:** YES\n`;
                statusReport += `**Last commit:** ${branch.data.commit.commit.author.date}\n`;
                statusReport += `**Commit SHA:** \`${branch.data.commit.sha.substring(0, 7)}\`\n\n`;

                // Try to get protection info
                try {
                  const protection = await github.rest.repos.getBranchProtection({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    branch: branchName
                  });

                  const reviews = protection.data.required_pull_request_reviews;
                  const checks = protection.data.required_status_checks;

                  statusReport += `**Protection Status:** PROTECTED ðŸ”’\n\n`;
                  statusReport += `**Protection Details:**\n`;
                  statusReport += `- Required approvals: ${reviews?.required_approving_review_count || 0}\n`;
                  statusReport += `- Code owner review: ${reviews?.require_code_owner_reviews ? 'YES' : 'NO'}\n`;
                  statusReport += `- Dismiss stale reviews: ${reviews?.dismiss_stale_reviews ? 'YES' : 'NO'}\n`;
                  statusReport += `- Last push approval: ${reviews?.require_last_push_approval ? 'YES' : 'NO'}\n`;
                  statusReport += `- Enforce for admins: ${protection.data.enforce_admins?.enabled ? 'YES' : 'NO'}\n`;
                  statusReport += `- Required checks: ${checks?.contexts?.join(', ') || 'None'}\n`;
                  statusReport += `- Strict status checks: ${checks?.strict ? 'YES' : 'NO'}\n`;
                  statusReport += `- Linear history: ${protection.data.required_linear_history?.enabled ? 'YES' : 'NO'}\n`;
                  statusReport += `- Conversation resolution: ${protection.data.required_conversation_resolution?.enabled ? 'YES' : 'NO'}\n`;
                  statusReport += `- Force pushes: ${protection.data.allow_force_pushes?.enabled ? 'ALLOWED' : 'BLOCKED'}\n`;
                  statusReport += `- Deletions: ${protection.data.allow_deletions?.enabled ? 'ALLOWED' : 'BLOCKED'}\n\n`;

                } catch (protectionError) {
                  if (protectionError.status === 404) {
                    statusReport += `**Protection Status:** NOT PROTECTED âš ï¸\n\n`;
                    statusReport += `âš ï¸ This branch exists but has no protection rules.\n`;
                    statusReport += `**Recommendation:** Enable branch protection immediately.\n\n`;
                  } else if (protectionError.status === 403) {
                    statusReport += `**Protection Status:** UNKNOWN (Permission Denied) ðŸ”\n\n`;
                    statusReport += `â„¹ï¸ Unable to check protection rules due to insufficient permissions.\n`;
                    statusReport += `This usually means:\n`;
                    statusReport += `- The GITHUB_TOKEN lacks admin permissions\n`;
                    statusReport += `- Branch protection exists but cannot be read\n`;
                    statusReport += `- A Personal Access Token (PAT) is needed for full access\n\n`;
                    statusReport += `**Alternative Method:**\n`;
                    statusReport += `1. Go to Settings > Branches\n`;
                    statusReport += `2. Check protection rules for \`${branchName}\` manually\n\n`;
                  } else {
                    statusReport += `**Protection Status:** ERROR âŒ\n\n`;
                    statusReport += `Error: ${protectionError.message}\n\n`;
                  }
                }

              } catch (branchError) {
                if (branchError.status === 404) {
                  statusReport += `#### Branch: \`${branchName}\` âŒ\n\n`;
                  statusReport += `**Branch exists:** NO\n`;
                  statusReport += `This branch has not been created yet.\n\n`;
                } else {
                  statusReport += `#### Branch: \`${branchName}\` âš ï¸\n\n`;
                  statusReport += `**Error checking branch:** ${branchError.message}\n\n`;
                }
              }
            }

            // Add repository-wide security settings
            statusReport += '---\n\n';
            statusReport += '## Repository Security Settings\n\n';
            
            statusReport += `**Visibility:** ${repo.data.private ? 'PRIVATE ðŸ”’' : 'PUBLIC ðŸŒ'}\n`;
            statusReport += `**Default Branch:** \`${repo.data.default_branch}\`\n`;
            statusReport += `**Vulnerability Alerts:** ${repo.data.has_vulnerability_alerts ? 'ENABLED âœ…' : 'DISABLED âŒ'}\n`;
            statusReport += `**Automated Security Fixes:** ${repo.data.security_and_analysis?.advanced_security?.status === 'enabled' ? 'ENABLED âœ…' : 'DISABLED âŒ'}\n`;
            statusReport += `**Allow Squash Merge:** ${repo.data.allow_squash_merge ? 'YES' : 'NO'}\n`;
            statusReport += `**Allow Merge Commit:** ${repo.data.allow_merge_commit ? 'YES' : 'NO'}\n`;
            statusReport += `**Allow Rebase Merge:** ${repo.data.allow_rebase_merge ? 'YES' : 'NO'}\n`;
            statusReport += `**Delete Branch on Merge:** ${repo.data.delete_branch_on_merge ? 'YES âœ…' : 'NO âš ï¸'}\n`;
            statusReport += `**Allow Auto-Merge:** ${repo.data.allow_auto_merge ? 'YES' : 'NO'}\n\n`;

            // Add recent activity summary
            statusReport += '## Recent Activity (Last 7 Days)\n\n';
            
            const weekAgo = new Date();
            weekAgo.setDate(weekAgo.getDate() - 7);
            
            const recentPRs = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'all',
              per_page: 100
            });
            
            const recentPRsFiltered = recentPRs.data.filter(pr => 
              new Date(pr.updated_at) >= weekAgo
            );
            
            statusReport += `**Pull Requests:** ${recentPRsFiltered.length} total\n`;
            statusReport += `- Open: ${recentPRsFiltered.filter(pr => pr.state === 'open').length}\n`;
            statusReport += `- Merged: ${recentPRsFiltered.filter(pr => pr.merged_at).length}\n`;
            statusReport += `- Closed: ${recentPRsFiltered.filter(pr => pr.state === 'closed' && !pr.merged_at).length}\n\n`;

            const recentCommits = await github.rest.repos.listCommits({
              owner: context.repo.owner,
              repo: context.repo.repo,
              since: weekAgo.toISOString(),
              per_page: 100
            });
            
            statusReport += `**Commits:** ${recentCommits.data.length}\n`;
            statusReport += `**Contributors:** ${[...new Set(recentCommits.data.map(c => c.author?.login))].filter(Boolean).length}\n\n`;

            // Add recommendations
            statusReport += '---\n\n';
            statusReport += '## Recommendations\n\n';
            
            const recommendations = [];
            
            if (!repo.data.private) {
              recommendations.push('âš ï¸ Repository is public - ensure no sensitive data is committed');
            }
            
            if (!repo.data.has_vulnerability_alerts) {
              recommendations.push('âŒ Enable vulnerability alerts in Settings > Security');
            }
            
            if (!repo.data.delete_branch_on_merge) {
              recommendations.push('âš ï¸ Enable automatic branch deletion to keep repository clean');
            }
            
            if (repo.data.allow_squash_merge && repo.data.allow_merge_commit && repo.data.allow_rebase_merge) {
              recommendations.push('â„¹ï¸ Consider restricting merge strategies to maintain consistent history');
            }
            
            if (recommendations.length > 0) {
              recommendations.forEach((rec, index) => {
                statusReport += `${index + 1}. ${rec}\n`;
              });
            } else {
              statusReport += 'âœ… No immediate recommendations - repository is well configured!\n';
            }
            
            statusReport += '\n---\n\n';
            statusReport += '**Note:** If you see "Permission Denied" errors above, create a Personal Access Token (PAT) with `repo` scope and add it as a repository secret named `ADMIN_TOKEN`. Then update the workflow to use `secrets.ADMIN_TOKEN` instead of `secrets.GITHUB_TOKEN` for admin operations.\n\n';
            statusReport += '*Generated by Professional Repository Protection System*';

            console.log(statusReport);

            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `Protection Status Report - ${new Date().toISOString().split('T')[0]}`,
              body: statusReport,
              labels: ['status-report', 'automation', 'security']
            });

  audit-report:
    needs: validate-user
    if: |
      (needs.validate-user.outputs.authorized == 'true' && github.event.inputs.action == 'audit-report') ||
      (github.event_name == 'schedule' && github.event.schedule == '0 8 * * 1')
    runs-on: ubuntu-latest
    steps:
      - name: Generate security audit
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const weekAgo = new Date();
            weekAgo.setDate(weekAgo.getDate() - 7);

            const prs = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'all',
              per_page: 100,
              sort: 'updated',
              direction: 'desc'
            });

            const recentPRs = prs.data.filter(pr => new Date(pr.updated_at) >= weekAgo);

            const commits = await github.rest.repos.listCommits({
              owner: context.repo.owner,
              repo: context.repo.repo,
              since: weekAgo.toISOString(),
              per_page: 100
            });

            let report = '### Weekly Security Audit\n\n';
            report += `**Period:** ${weekAgo.toLocaleDateString()} - ${new Date().toLocaleDateString()}\n\n`;
            
            report += `#### Activity Summary\n\n`;
            report += `- Total PRs: ${recentPRs.length}\n`;
            report += `- Direct commits: ${commits.data.length}\n`;
            report += `- PRs merged: ${recentPRs.filter(pr => pr.merged_at).length}\n`;
            report += `- PRs open: ${recentPRs.filter(pr => pr.state === 'open').length}\n`;
            report += `- PRs closed: ${recentPRs.filter(pr => pr.state === 'closed' && !pr.merged_at).length}\n\n`;

            if (recentPRs.filter(pr => pr.merged_at).length > 0) {
              report += `#### Recent Merged PRs\n\n`;
              recentPRs.filter(pr => pr.merged_at).slice(0, 10).forEach(pr => {
                report += `- #${pr.number}: ${pr.title} (by @${pr.merged_by?.login || 'unknown'})\n`;
              });
              report += `\n`;
            }

            report += `---\n`;
            report += `**Special Admins:** ${process.env.SPECIAL_ADMINS}\n`;
            report += `**Note:** All repository maintainers are also authorized\n`;

            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `Security Audit - ${new Date().toISOString().split('T')[0]}`,
              body: report,
              labels: ['security-audit', 'weekly-report']
            });

  create-security-guidelines:
    name: Post Security Guidelines
    needs: [validate-user, apply-protection]
    if: |
      needs.validate-user.outputs.authorized == 'true' &&
      github.event.inputs.action == 'lock-it-down' &&
      needs.apply-protection.result == 'success'
    runs-on: ubuntu-latest
    steps:
      - name: Post security guidelines
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const approvals = '${{ github.event.inputs.approval_count }}';
            const specialAdmins = process.env.SPECIAL_ADMINS.split(',').map(a => '@' + a).join(', ');

            const existing = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: ['security-guidelines'],
              state: 'open'
            });

            for (const issue of existing.data) {
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                state: 'closed',
                state_reason: 'completed'
              });
            }

            const newIssue = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: 'LOCKDOWN: Repository Security Rules',
              body: `# Repository Security Rules\n\n` +
                    `This repository is under strict security protection.\n\n` +
                    `---\n\n` +
                    `## Allowed Actions\n\n` +
                    `- Create feature branches from main/master\n` +
                    `- Open pull requests with detailed descriptions\n` +
                    `- Pass all required security scans\n` +
                    `- Pass Vercel deployment checks\n` +
                    `- Pass Sentry error tracking validation\n` +
                    `- Obtain ${approvals} required approvals\n` +
                    `- Get code owner review approval\n` +
                    `- Resolve all conversations\n` +
                    `- Use bot commands for approvals\n\n` +
                    `## Forbidden Actions\n\n` +
                    `- Direct pushes to protected branches\n` +
                    `- Merging without required approvals\n` +
                    `- Merging with failing security scans\n` +
                    `- Merging with failing Vercel checks\n` +
                    `- Merging with Sentry errors\n` +
                    `- Force pushing or deleting branches\n` +
                    `- Bypassing conversation resolution\n` +
                    `- Bypassing linear history requirements\n\n` +
                    `## Forbidden Content\n\n` +
                    `**File Types:**\n` +
                    `- .pem, .key, .p12, .pfx, .keystore files\n` +
                    `- .env files and variants\n` +
                    `- Files in /secrets/ directory\n` +
                    `- SSH private keys\n` +
                    `- Configuration files with credentials\n\n` +
                    `**Sensitive Data:**\n` +
                    `- API keys and tokens\n` +
                    `- AWS credentials (AKIA...)\n` +
                    `- GitHub tokens (ghp_, gho_...)\n` +
                    `- OpenAI keys (sk-...)\n` +
                    `- Vercel tokens\n` +
                    `- Sentry DSN (monitored)\n` +
                    `- Private keys and certificates\n` +
                    `- Database credentials\n` +
                    `- Passwords and secrets\n` +
                    `- JWT tokens\n` +
                    `- OAuth secrets\n\n` +
                    `## Required Status Checks\n\n` +
                    `All PRs must pass:\n` +
                    `- **security-scan** - Automated security scanning\n` +
                    `- **vercel-check** - Vercel deployment validation\n` +
                    `- **sentry-check** - Sentry error tracking\n\n` +
                    `---\n\n` +
                    `## Bot Commands\n\n` +
                    `Authorized users can use:\n` +
                    `- \`/bot approve\` - Approve PR for merge\n` +
                    `- \`/bot reject [reason]\` - Reject PR with reason\n` +
                    `- \`/bot status\` - Check PR status\n\n` +
                    `PRs with forbidden content will be flagged during security scans.\n\n` +
                    `---\n\n` +
                    `## Authorization\n\n` +
                    `**Repository Owner:** @${{ github.repository_owner }}\n` +
                    `**All Maintainers:** Anyone with write/maintain/admin access\n` +
                    `**Special Admins:** ${specialAdmins}\n\n` +
                    `**Protection activated by:** @${{ github.actor }}\n` +
                    `**Protection level:** ${approvals} required approvals\n` +
                    `**Admin enforcement:** YES\n` +
                    `**Code owner review:** YES\n` +
                    `**Linear history:** YES\n` +
                    `**Date:** ${new Date().toLocaleString()}\n\n` +
                    `---\n\n` +
                    `**Developed by:**\n` +
                    `- Kinsta (kinsta)\n` +
                    `- GetSentry (getsentry) - Sentry error tracking\n` +
                    `- ThnxDev (thnxdev)\n` +
                    `- Vercel (vercel) - Deployment platform\n` +
                    `- Wasmer (wasmer)\n` +
                    `- CodeRabbit AI (coderabbit-ai) - Automated code review`,
              labels: ['security-guidelines', 'documentation', 'pinned']
            });

            console.log('Created security guidelines issue #' + newIssue.data.number);

  security-scan:
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Comprehensive security scan
        id: scan
        continue-on-error: true
        run: |
          echo "Starting comprehensive security scan..."
          
          base_sha="${{ github.event.pull_request.base.sha }}"
          head_sha="${{ github.event.pull_request.head.sha }}"
          
          changed_files=$(git diff --name-only "$base_sha" "$head_sha" 2>/dev/null || true)

          if [ -z "$changed_files" ]; then
            echo "scan_result=passed" >> $GITHUB_OUTPUT
            echo "scan_details=No files changed" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "Files changed:"
          echo "$changed_files"
          echo ""
          
          # Check for forbidden file types in PR changes only
          forbidden_found=""
          echo "$changed_files" | while IFS= read -r file; do
            if [ -f "$file" ]; then
              case "$file" in
                *.pem|*.key|*.p12|*.env)
                  echo "::error::Forbidden file type: $file"
                  forbidden_found="true"
                  ;;
                */secrets/*)
                  echo "::error::File in forbidden directory: $file"
                  forbidden_found="true"
                  ;;
              esac
            fi
          done
          
          if [ -n "$forbidden_found" ]; then
            echo "::error::Forbidden files detected in PR"
            exit 1
          fi
          
          echo "No forbidden files found in PR changes"
          
          # Check for potential secrets in changed files only
          secrets_found=""
          echo "$changed_files" | while IFS= read -r file; do
            if [ -f "$file" ]; then
              # Skip workflow files and config files in .github
              if [[ "$file" == .github/* ]]; then
                echo "Skipping repository file: $file"
                continue
              fi
              
              # Check for secrets
              if grep -l -E "(AKIA[0-9A-Z]{16}|ghp_[a-zA-Z0-9]{36}|gho_[a-zA-Z0-9]{36}|github_pat_[a-zA-Z0-9]{22}_[a-zA-Z0-9]{59})" "$file" >/dev/null 2>&1; then
                echo "::error::Potential AWS or GitHub secrets found in: $file"
                secrets_found="true"
              elif grep -l -E "(sk-[a-zA-Z0-9]{48}|api[_-]?key['\"]?\s*[:=]\s*['\"][a-zA-Z0-9]{32,})" "$file" >/dev/null 2>&1; then
                echo "::error::Potential API keys found in: $file"
                secrets_found="true"
              elif grep -l -E "(password['\"]?\s*[:=]\s*['\"][^'\"]{8,}|passwd['\"]?\s*[:=]\s*['\"][^'\"]{8,})" "$file" >/dev/null 2>&1; then
                echo "::error::Potential passwords found in: $file"
                secrets_found="true"
              fi
            fi
          done
          
          if [ -n "$secrets_found" ]; then
            echo "::error::Potential secrets detected in PR"
            exit 1
          fi
          
          echo "Security scan passed successfully"
      
      - name: Comment on PR with scan results
        if: github.event_name == 'pull_request' && always()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const scanResult = '${{ steps.scan.outputs.scan_result }}';
            const scanDetails = '${{ steps.scan.outputs.scan_details }}';
            const prNumber = context.issue.number;

            let body = '';
            if (scanResult === 'passed') {
              body = '### Security Scan Results\n\n' +
                     '**Status:** PASSED âœ…\n\n' +
                     'All security checks completed successfully:\n' +
                     '- No forbidden files detected\n' +
                     '- No secrets found\n' +
                     '- No security warnings\n\n' +
                     'This PR is ready for review.\n\n' +
                     '---\n' +
                     'Waiting for required checks: vercel-check, sentry-check';
            } else if (scanResult === 'warning') {
              const details = scanDetails.replace(/\\n/g, '\n');
              const warningCount = '${{ steps.scan.outputs.warning_count }}' || '0';
              body = '### Security Scan Results\n\n' +
                     '**Status:** WARNING âš ï¸\n\n' +
                     `**Warnings Found:** ${warningCount}\n\n` +
                     'Potential issues detected:\n\n```\n' +
                     details + '\n```\n\n' +
                     'Please review these warnings carefully before merging.\n\n' +
                     '---\n' +
                     'Admin approval recommended.';
            } else if (scanResult === 'failed') {
              const details = scanDetails.replace(/\\n/g, '\n');
              const forbiddenCount = '${{ steps.scan.outputs.forbidden_count }}' || '0';
              const secretCount = '${{ steps.scan.outputs.secret_count }}' || '0';
              body = '### Security Scan Results\n\n' +
                     '**Status:** FAILED âŒ\n\n' +
                     `**Violations Found:**\n` +
                     `- Forbidden files: ${forbiddenCount}\n` +
                     `- Secrets detected: ${secretCount}\n\n` +
                     '```\n' + details + '\n```\n\n' +
                     'This PR cannot be merged until all security violations are resolved.\n\n' +
                     '---\n' +
                     'Contact authorized admins for guidance.';
            } else if (scanResult === 'critical') {
              const details = scanDetails.replace(/\\n/g, '\n');
              const criticalCount = '${{ steps.scan.outputs.critical_count }}' || '0';
              const forbiddenCount = '${{ steps.scan.outputs.forbidden_count }}' || '0';
              const secretCount = '${{ steps.scan.outputs.secret_count }}' || '0';
              body = '### Security Scan Results\n\n' +
                     '**Status:** CRITICAL FAILURE ðŸš¨\n\n' +
                     `**CRITICAL SECURITY VIOLATIONS:**\n` +
                     `- Critical issues: ${criticalCount}\n` +
                     `- Forbidden files: ${forbiddenCount}\n` +
                     `- Secrets detected: ${secretCount}\n\n` +
                     '```\n' + details + '\n```\n\n' +
                     'â›” **THIS PR IS BLOCKED**\n\n' +
                     'Critical security violations must be fixed immediately.\n' +
                     'Remove all sensitive credentials and forbidden files.\n\n' +
                     '---\n' +
                     '**Next Steps:**\n' +
                     '1. Remove all flagged files and secrets\n' +
                     '2. Rotate any exposed credentials\n' +
                     '3. Update PR and request re-scan\n' +
                     '4. Contact security team if needed';
            } else {
              body = '### Security Scan Results\n\n' +
                     '**Status:** PASSED âœ…\n\n' +
                     'No changes to scan.';
            }

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: body
            });

  bot-command-handler:
    name: Handle Bot Commands
    runs-on: ubuntu-latest
    if: github.event_name == 'issue_comment' && github.event.issue.pull_request
    steps:
      - name: Check user authorization
        id: auth_check
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const commenter = context.payload.comment.user.login;
            const owner = context.repo.owner;
            const specialAdmins = process.env.SPECIAL_ADMINS.split(',');

            // Check if commenter is owner - ALWAYS AUTHORIZED
            if (commenter === owner) {
              core.setOutput('authorized', 'true');
              core.setOutput('commenter', commenter);
              core.setOutput('role', 'owner');
              return true;
            }

            // Check if commenter is a bot - ALL BOTS ARE AUTHORIZED
            if (commenter.endsWith('[bot]')) {
              const baseName = commenter.replace('[bot]', '');
              const isWhitelisted = specialAdmins.includes(baseName) || specialAdmins.includes(commenter);
              
              core.setOutput('authorized', 'true');
              core.setOutput('commenter', commenter);
              core.setOutput('role', isWhitelisted ? 'special_admin_bot' : 'bot');
              return true;
            }

            // Check if commenter is special admin
            if (specialAdmins.includes(commenter)) {
              core.setOutput('authorized', 'true');
              core.setOutput('commenter', commenter);
              core.setOutput('role', 'special_admin');
              return true;
            }

            // Check if commenter has sufficient permissions
            try {
              const { data: permission } = await github.rest.repos.getCollaboratorPermissionLevel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                username: commenter
              });
              
              const userPermission = permission.permission;
              
              if (userPermission === 'admin' || userPermission === 'maintain' || userPermission === 'write') {
                core.setOutput('authorized', 'true');
                core.setOutput('commenter', commenter);
                core.setOutput('role', userPermission);
                return true;
              }
            } catch (error) {
              console.log('Could not check permissions: ' + error.message);
            }

            core.setOutput('authorized', 'false');
            core.setOutput('commenter', commenter);
            core.setOutput('role', 'none');
            return false;

      - name: Process bot command
        if: steps.auth_check.outputs.authorized == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const comment = context.payload.comment.body.trim().toLowerCase();
            const prNumber = context.issue.number;
            const commenter = '${{ steps.auth_check.outputs.commenter }}';
            const role = '${{ steps.auth_check.outputs.role }}';

            if (comment.startsWith('/bot approve')) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: '### PR Approved âœ…\n\n' +
                      'Approved by: @' + commenter + ' (' + role + ')\n\n' +
                      'This PR has been reviewed and approved.\n\n' +
                      'Status: APPROVED'
              });

              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                labels: ['approved', 'ready-to-merge']
              });

            } else if (comment.startsWith('/bot reject')) {
              const reason = comment.replace('/bot reject', '').trim() || 'No reason provided';

              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: '### PR Rejected âŒ\n\n' +
                      'Rejected by: @' + commenter + ' (' + role + ')\n' +
                      'Reason: ' + reason + '\n\n' +
                      'Status: CHANGES REQUESTED'
              });

              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                labels: ['changes-requested']
              });

            } else if (comment.startsWith('/bot status')) {
              const pr = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber
              });

              const reviews = await github.rest.pulls.listReviews({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber
              });

              const checks = await github.rest.checks.listForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: pr.data.head.sha
              });

              const approvals = reviews.data.filter(r => r.state === 'APPROVED').length;
              const checksStatus = checks.data.check_runs.map(c => `${c.name}: ${c.conclusion || c.status}`).join('\n');

              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: '### PR Status Check ðŸ“Š\n\n' +
                      `**Approvals:** ${approvals}\n` +
                      `**Mergeable:** ${pr.data.mergeable ? 'YES' : 'NO'}\n` +
                      `**Merge State:** ${pr.data.mergeable_state}\n` +
                      `**Status Checks:**\n\`\`\`\n${checksStatus || 'None'}\n\`\`\`\n\n` +
                      'Requested by: @' + commenter
              });

            } else if (comment.startsWith('/bot')) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: '### Unknown Command\n\n' +
                      'Available commands:\n' +
                      '- `/bot approve` - Approve PR\n' +
                      '- `/bot reject [reason]` - Reject PR\n' +
                      '- `/bot status` - Check PR status'
              });
            }

      - name: Unauthorized command
        if: steps.auth_check.outputs.authorized == 'false'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const comment = context.payload.comment.body.trim();
            if (comment.toLowerCase().startsWith('/bot')) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: 'Only repository maintainers and authorized admins can use bot commands.\n\n' +
                      'Special admins: ' + process.env.SPECIAL_ADMINS
              });
            }

  security-health-check:
    needs: validate-user
    if: |
      (needs.validate-user.outputs.authorized == 'true' && github.event.inputs.action == 'security-health-check') ||
      (github.event_name == 'schedule' && github.event.schedule == '0 */6 * * *')
    runs-on: ubuntu-latest
    steps:
      - name: Comprehensive security health check
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            console.log('=== SECURITY HEALTH CHECK ===');
            
            let healthReport = '# Security Health Check Report\n\n';
            healthReport += `**Generated:** ${new Date().toLocaleString()}\n`;
            healthReport += `**Scan Version:** ${process.env.SECURITY_SCAN_VERSION}\n\n`;
            healthReport += '---\n\n';
            
            let overallScore = 100;
            let criticalIssues = 0;
            let warnings = 0;
            let recommendations = [];
            
            // Check 1: Branch Protection Status
            healthReport += '## 1. Branch Protection Status\n\n';
            const protectedBranches = process.env.PROTECTED_BRANCHES.split(',');
            let protectedCount = 0;
            let unprotectedCount = 0;
            
            for (const branch of protectedBranches) {
              try {
                const protection = await github.rest.repos.getBranchProtection({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  branch: branch
                });
                protectedCount++;
                healthReport += `- âœ… \`${branch}\` - PROTECTED\n`;
                
                // Check protection strength
                const reviews = protection.data.required_pull_request_reviews;
                if (!reviews || reviews.required_approving_review_count < 2) {
                  warnings++;
                  overallScore -= 5;
                  recommendations.push(`Increase required approvals for ${branch} to at least 2`);
                }
                
                if (!protection.data.enforce_admins?.enabled) {
                  warnings++;
                  overallScore -= 10;
                  recommendations.push(`Enable admin enforcement for ${branch}`);
                }
                
              } catch (e) {
                if (e.status === 404) {
                  unprotectedCount++;
                  criticalIssues++;
                  overallScore -= 20;
                  healthReport += `- âŒ \`${branch}\` - NOT PROTECTED\n`;
                  recommendations.push(`CRITICAL: Enable branch protection for ${branch}`);
                }
              }
            }
            
            healthReport += `\n**Summary:** ${protectedCount} protected, ${unprotectedCount} unprotected\n\n`;
            
            // Check 2: Recent Security Incidents
            healthReport += '## 2. Recent Security Incidents\n\n';
            const weekAgo = new Date();
            weekAgo.setDate(weekAgo.getDate() - 7);
            
            const recentIssues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'all',
              labels: 'security',
              since: weekAgo.toISOString()
            });
            
            if (recentIssues.data.length === 0) {
              healthReport += 'âœ… No security incidents in the last 7 days\n\n';
            } else {
              healthReport += `âš ï¸ ${recentIssues.data.length} security-related issue(s) found:\n\n`;
              recentIssues.data.slice(0, 5).forEach(issue => {
                healthReport += `- #${issue.number}: ${issue.title} [${issue.state}]\n`;
              });
              warnings += recentIssues.data.length;
              overallScore -= Math.min(recentIssues.data.length * 2, 10);
              healthReport += '\n';
            }
            
            // Check 3: Failed Security Scans
            healthReport += '## 3. Failed Security Scans (Last 24 Hours)\n\n';
            const dayAgo = new Date();
            dayAgo.setDate(dayAgo.getDate() - 1);
            
            const workflowRuns = await github.rest.actions.listWorkflowRunsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              created: `>${dayAgo.toISOString()}`,
              per_page: 100
            });
            
            const failedSecurityScans = workflowRuns.data.workflow_runs.filter(run => 
              run.name.includes('security') && run.conclusion === 'failure'
            );
            
            if (failedSecurityScans.length === 0) {
              healthReport += 'âœ… No failed security scans\n\n';
            } else {
              healthReport += `âŒ ${failedSecurityScans.length} failed security scan(s):\n\n`;
              failedSecurityScans.slice(0, 5).forEach(run => {
                healthReport += `- ${run.name} - ${run.created_at}\n`;
              });
              criticalIssues += failedSecurityScans.length;
              overallScore -= Math.min(failedSecurityScans.length * 5, 20);
              healthReport += '\n';
            }
            
            // Check 4: Open Pull Requests Security Status
            healthReport += '## 4. Open Pull Requests\n\n';
            const openPRs = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              per_page: 100
            });
            
            let unsafePRs = 0;
            for (const pr of openPRs.data) {
              const checks = await github.rest.checks.listForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: pr.head.sha
              });
              
              const failedChecks = checks.data.check_runs.filter(c => 
                c.conclusion === 'failure' && c.name.includes('security')
              );
              
              if (failedChecks.length > 0) {
                unsafePRs++;
              }
            }
            
            healthReport += `**Total Open PRs:** ${openPRs.data.length}\n`;
            healthReport += `**PRs with Security Issues:** ${unsafePRs}\n\n`;
            
            if (unsafePRs > 0) {
              warnings += unsafePRs;
              overallScore -= Math.min(unsafePRs * 3, 15);
              recommendations.push(`Review and fix security issues in ${unsafePRs} open PR(s)`);
            }
            
            // Check 5: Dependabot/Security Alerts
            healthReport += '## 5. Security Vulnerabilities\n\n';
            
            try {
              const alerts = await github.rest.dependabot.listAlertsForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open'
              });
              
              const critical = alerts.data.filter(a => a.security_vulnerability.severity === 'critical').length;
              const high = alerts.data.filter(a => a.security_vulnerability.severity === 'high').length;
              const medium = alerts.data.filter(a => a.security_vulnerability.severity === 'medium').length;
              const low = alerts.data.filter(a => a.security_vulnerability.severity === 'low').length;
              
              healthReport += `**Critical:** ${critical}\n`;
              healthReport += `**High:** ${high}\n`;
              healthReport += `**Medium:** ${medium}\n`;
              healthReport += `**Low:** ${low}\n\n`;
              
              if (critical > 0) {
                criticalIssues += critical;
                overallScore -= critical * 10;
                recommendations.push(`URGENT: Fix ${critical} critical vulnerabilities`);
              }
              if (high > 0) {
                warnings += high;
                overallScore -= high * 5;
                recommendations.push(`Fix ${high} high severity vulnerabilities`);
              }
              
            } catch (error) {
              healthReport += 'âš ï¸ Unable to fetch vulnerability data\n\n';
            }
            
            // Check 6: Repository Settings
            healthReport += '## 6. Repository Security Settings\n\n';
            const repo = await github.rest.repos.get({
              owner: context.repo.owner,
              repo: context.repo.repo
            });
            
            const settings = [];
            if (!repo.data.private) {
              settings.push('âš ï¸ Repository is PUBLIC');
              warnings++;
              recommendations.push('Consider if repository should be private');
            } else {
              settings.push('âœ… Repository is PRIVATE');
            }
            
            if (repo.data.has_vulnerability_alerts) {
              settings.push('âœ… Vulnerability alerts enabled');
            } else {
              settings.push('âŒ Vulnerability alerts disabled');
              criticalIssues++;
              overallScore -= 15;
              recommendations.push('CRITICAL: Enable vulnerability alerts');
            }
            
            if (repo.data.allow_squash_merge && repo.data.allow_merge_commit && repo.data.allow_rebase_merge) {
              settings.push('âš ï¸ All merge types allowed');
              warnings++;
              recommendations.push('Restrict merge types to squash or rebase only');
            } else {
              settings.push('âœ… Merge types restricted');
            }
            
            if (repo.data.delete_branch_on_merge) {
              settings.push('âœ… Auto-delete branches enabled');
            } else {
              settings.push('âš ï¸ Auto-delete branches disabled');
              warnings++;
            }
            
            healthReport += settings.join('\n') + '\n\n';
            
            // Check 7: Workflow Security
            healthReport += '## 7. GitHub Actions Security\n\n';
            
            const workflows = await github.rest.actions.listRepoWorkflows({
              owner: context.repo.owner,
              repo: context.repo.repo
            });
            
            healthReport += `**Active Workflows:** ${workflows.data.total_count}\n`;
            
            let workflowIssues = 0;
            for (const workflow of workflows.data.workflows) {
              if (workflow.state === 'active') {
                // Check for workflows with broad permissions
                // This is a simplified check
                workflowIssues++;
              }
            }
            
            if (workflows.data.total_count > 20) {
              warnings++;
              recommendations.push('Consider consolidating workflows for better management');
            }
            
            healthReport += '\n';
            
            // Calculate final score
            overallScore = Math.max(0, Math.min(100, overallScore));
            
            // Overall Assessment
            healthReport += '---\n\n';
            healthReport += '## Overall Security Assessment\n\n';
            
            let scoreEmoji = 'ðŸ”´';
            let scoreLevel = 'CRITICAL';
            
            if (overallScore >= 90) {
              scoreEmoji = 'ðŸŸ¢';
              scoreLevel = 'EXCELLENT';
            } else if (overallScore >= 75) {
              scoreEmoji = 'ðŸŸ¡';
              scoreLevel = 'GOOD';
            } else if (overallScore >= 60) {
              scoreEmoji = 'ðŸŸ ';
              scoreLevel = 'FAIR';
            } else if (overallScore >= 40) {
              scoreEmoji = 'ðŸ”´';
              scoreLevel = 'POOR';
            }
            
            healthReport += `### Security Score: ${overallScore}/100 ${scoreEmoji}\n\n`;
            healthReport += `**Level:** ${scoreLevel}\n\n`;
            healthReport += `**Critical Issues:** ${criticalIssues}\n`;
            healthReport += `**Warnings:** ${warnings}\n\n`;
            
            // Recommendations
            if (recommendations.length > 0) {
              healthReport += '## Recommendations\n\n';
              recommendations.forEach((rec, index) => {
                healthReport += `${index + 1}. ${rec}\n`;
              });
              healthReport += '\n';
            } else {
              healthReport += '## Recommendations\n\n';
              healthReport += 'âœ… No immediate actions required. Keep up the good work!\n\n';
            }
            
            healthReport += '---\n\n';
            healthReport += `*Next health check: ${new Date(Date.now() + 6*60*60*1000).toLocaleString()}*\n`;
            
            // Create issue
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `Security Health Check - ${scoreLevel} (${overallScore}/100) - ${new Date().toISOString().split('T')[0]}`,
              body: healthReport,
              labels: ['security-health', 'automated-report', scoreLevel.toLowerCase()]
            });

  compliance-report:
    needs: validate-user
    if: |
      (needs.validate-user.outputs.authorized == 'true' && github.event.inputs.action == 'compliance-report') ||
      (github.event_name == 'schedule' && github.event.schedule == '0 12 * * 0')
    runs-on: ubuntu-latest
    steps:
      - name: Generate compliance report
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            console.log('=== COMPLIANCE REPORT GENERATION ===');
            
            let complianceReport = '# Repository Compliance Report\n\n';
            complianceReport += `**Generated:** ${new Date().toLocaleString()}\n`;
            complianceReport += `**Reporting Period:** Last 30 days\n\n`;
            complianceReport += '---\n\n';
            
            const thirtyDaysAgo = new Date();
            thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
            
            // 1. Code Review Compliance
            complianceReport += '## 1. Code Review Compliance\n\n';
            
            const allPRs = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'closed',
              per_page: 100,
              sort: 'updated',
              direction: 'desc'
            });
            
            const recentMergedPRs = allPRs.data.filter(pr => 
              pr.merged_at && new Date(pr.merged_at) >= thirtyDaysAgo
            );
            
            let reviewedPRs = 0;
            let unreviewed PRs = 0;
            let insufficientReviews = 0;
            
            for (const pr of recentMergedPRs) {
              const reviews = await github.rest.pulls.listReviews({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number
              });
              
              const approvals = reviews.data.filter(r => r.state === 'APPROVED').length;
              
              if (approvals === 0) {
                unreviewedPRs++;
              } else if (approvals === 1) {
                insufficientReviews++;
              } else {
                reviewedPRs++;
              }
            }
            
            const totalMerged = recentMergedPRs.length;
            const complianceRate = totalMerged > 0 ? ((reviewedPRs / totalMerged) * 100).toFixed(1) : 100;
            
            complianceReport += `**Total Merged PRs:** ${totalMerged}\n`;
            complianceReport += `**Properly Reviewed (2+ approvals):** ${reviewedPRs}\n`;
            complianceReport += `**Insufficient Reviews (1 approval):** ${insufficientReviews}\n`;
            complianceReport += `**No Reviews:** ${unreviewedPRs}\n`;
            complianceReport += `**Compliance Rate:** ${complianceRate}%\n\n`;
            
            if (unreviewedPRs > 0) {
              complianceReport += `âš ï¸ **WARNING:** ${unreviewedPRs} PR(s) merged without review\n\n`;
            }
            
            // 2. Security Scan Compliance
            complianceReport += '## 2. Security Scan Compliance\n\n';
            
            const workflowRuns = await github.rest.actions.listWorkflowRunsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              created: `>${thirtyDaysAgo.toISOString()}`,
              per_page: 100
            });
            
            const securityScans = workflowRuns.data.workflow_runs.filter(run =>
              run.name.toLowerCase().includes('security')
            );
            
            const passedScans = securityScans.filter(r => r.conclusion === 'success').length;
            const failedScans = securityScans.filter(r => r.conclusion === 'failure').length;
            const scanComplianceRate = securityScans.length > 0 ? 
              ((passedScans / securityScans.length) * 100).toFixed(1) : 100;
            
            complianceReport += `**Total Security Scans:** ${securityScans.length}\n`;
            complianceReport += `**Passed:** ${passedScans}\n`;
            complianceReport += `**Failed:** ${failedScans}\n`;
            complianceReport += `**Success Rate:** ${scanComplianceRate}%\n\n`;
            
            // 3. Branch Protection Compliance
            complianceReport += '## 3. Branch Protection Compliance\n\n';
            
            const protectedBranches = process.env.PROTECTED_BRANCHES.split(',');
            let protectionCompliance = [];
            
            for (const branch of protectedBranches) {
              try {
                const protection = await github.rest.repos.getBranchProtection({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  branch: branch
                });
                
                const reviews = protection.data.required_pull_request_reviews;
                const checks = protection.data.required_status_checks;
                const enforceAdmins = protection.data.enforce_admins?.enabled;
                
                let status = 'âœ… Compliant';
                if (!reviews || reviews.required_approving_review_count < 2) {
                  status = 'âš ï¸ Needs more approvals';
                } else if (!enforceAdmins) {
                  status = 'âš ï¸ Admin bypass enabled';
                } else if (!checks || checks.contexts.length === 0) {
                  status = 'âš ï¸ No required checks';
                }
                
                protectionCompliance.push(`- \`${branch}\`: ${status}`);
                
              } catch (e) {
                protectionCompliance.push(`- \`${branch}\`: âŒ Not protected`);
              }
            }
            
            complianceReport += protectionCompliance.join('\n') + '\n\n';
            
            // 4. Dependency Update Compliance
            complianceReport += '## 4. Dependency Update Compliance\n\n';
            
            try {
              const openAlerts = await github.rest.dependabot.listAlertsForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open'
              });
              
              const oldAlerts = openAlerts.data.filter(alert => {
                const created = new Date(alert.created_at);
                const ageInDays = (Date.now() - created.getTime()) / (1000 * 60 * 60 * 24);
                return ageInDays > 30;
              });
              
              complianceReport += `**Open Security Alerts:** ${openAlerts.data.length}\n`;
              complianceReport += `**Alerts Open >30 Days:** ${oldAlerts.length}\n\n`;
              
              if (oldAlerts.length > 0) {
                complianceReport += `âš ï¸ **WARNING:** ${oldAlerts.length} security alert(s) unresolved for over 30 days\n\n`;
              }
              
            } catch (error) {
              complianceReport += 'âš ï¸ Unable to fetch dependency data\n\n';
            }
            
            // 5. Commit Signing Compliance
            complianceReport += '## 5. Commit Signing Status\n\n';
            
            const recentCommits = await github.rest.repos.listCommits({
              owner: context.repo.owner,
              repo: context.repo.repo,
              since: thirtyDaysAgo.toISOString(),
              per_page: 100
            });
            
            const signedCommits = recentCommits.data.filter(c => c.commit.verification?.verified).length;
            const totalCommits = recentCommits.data.length;
            const signingRate = totalCommits > 0 ? ((signedCommits / totalCommits) * 100).toFixed(1) : 0;
            
            complianceReport += `**Total Commits:** ${totalCommits}\n`;
            complianceReport += `**Signed Commits:** ${signedCommits}\n`;
            complianceReport += `**Signing Rate:** ${signingRate}%\n\n`;
            
            if (signingRate < 100) {
              complianceReport += `âš ï¸ **RECOMMENDATION:** Enable required commit signing\n\n`;
            }
            
            // 6. Access Control Compliance
            complianceReport += '## 6. Access Control Review\n\n';
            
            const collaborators = await github.rest.repos.listCollaborators({
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 100
            });
            
            const adminUsers = collaborators.data.filter(c => c.permissions.admin).length;
            const maintainers = collaborators.data.filter(c => c.permissions.maintain && !c.permissions.admin).length;
            const writers = collaborators.data.filter(c => c.permissions.push && !c.permissions.maintain && !c.permissions.admin).length;
            const readers = collaborators.data.filter(c => c.permissions.pull && !c.permissions.push).length;
            
            complianceReport += `**Total Collaborators:** ${collaborators.data.length}\n`;
            complianceReport += `- Admins: ${adminUsers}\n`;
            complianceReport += `- Maintainers: ${maintainers}\n`;
            complianceReport += `- Writers: ${writers}\n`;
            complianceReport += `- Readers: ${readers}\n\n`;
            
            if (adminUsers > 5) {
              complianceReport += `âš ï¸ **RECOMMENDATION:** Review admin access - ${adminUsers} users have admin permissions\n\n`;
            }
            
            // Overall Compliance Score
            complianceReport += '---\n\n';
            complianceReport += '## Overall Compliance Summary\n\n';
            
            const metrics = [
              { name: 'Code Review', rate: parseFloat(complianceRate), weight: 30 },
              { name: 'Security Scans', rate: parseFloat(scanComplianceRate), weight: 25 },
              { name: 'Commit Signing', rate: parseFloat(signingRate), weight: 20 },
              { name: 'Branch Protection', rate: (protectionCompliance.filter(p => p.includes('âœ…')).length / protectedBranches.length) * 100, weight: 25 }
            ];
            
            const overallScore = metrics.reduce((sum, m) => sum + (m.rate * m.weight / 100), 0);
            
            let grade = 'F';
            if (overallScore >= 90) grade = 'A';
            else if (overallScore >= 80) grade = 'B';
            else if (overallScore >= 70) grade = 'C';
            else if (overallScore >= 60) grade = 'D';
            
            complianceReport += `### Compliance Score: ${overallScore.toFixed(1)}/100 (Grade: ${grade})\n\n`;
            
            complianceReport += '**Breakdown:**\n';
            metrics.forEach(m => {
              complianceReport += `- ${m.name}: ${m.rate.toFixed(1)}% (${m.weight}% weight)\n`;
            });
            complianceReport += '\n';
            
            // Recommendations
            complianceReport += '## Action Items\n\n';
            
            const actions = [];
            if (unreviewedPRs > 0) actions.push(`Review merge policy - ${unreviewedPRs} PRs merged without review`);
            if (failedScans > 0) actions.push(`Address ${failedScans} failed security scans`);
            if (signingRate < 100) actions.push('Enable required commit signing');
            if (adminUsers > 5) actions.push('Audit admin access permissions');
            
            if (actions.length > 0) {
              actions.forEach((action, index) => {
                complianceReport += `${index + 1}. ${action}\n`;
              });
            } else {
              complianceReport += 'âœ… No critical action items. Maintaining excellent compliance!\n';
            }
            
            complianceReport += '\n---\n\n';
            complianceReport += '*This report is generated automatically every Sunday for compliance tracking.*\n';
            
            // Create compliance issue
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `Compliance Report - Grade ${grade} (${overallScore.toFixed(1)}/100) - ${new Date().toISOString().split('T')[0]}`,
              body: complianceReport,
              labels: ['compliance-report', 'automated-report', `grade-${grade.toLowerCase()}`]
            });
