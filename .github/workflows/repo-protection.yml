emergency-unlock:
    name: Emergency Unlock
    runs-on: ubuntu-latest
    needs: validate-user
    if: needs.validate-user.outputs.authorized == 'true' && github.event.inputs.action == 'emergency-unlock'
    
    steps:
      - name: Emergency Protection Disable
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            console.log('🚨 EMERGENCY: Disabling all protection immediately...');
            
            const branches = ['main', 'master'];
            const unlockedBranches = [];
            
            for (const branch of branches) {
              try {
                await github.rest.repos.deleteBranchProtection({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  branch: branch
                });
                unlockedBranches.push(branch);
                console.log(`🚨 EMERGENCY: ${branch} protection DISABLED`);
              } catch (error) {
                if (error.status === 404) {
                  console.log(`ℹ️ ${branch} was not protected`);
                } else {
                  console.warn(`⚠️ Could not disable ${branch} protection:`, error.message);
                }
              }
            }
            
            if (unlockedBranches.length === 0) {
              console.log('ℹ️ No protected branches found to unlock');
            } else {
              console.log(`🚨 EMERGENCY COMPLETE: ${unlockedBranches.length} branch(es) unlocked`);
            }

      - name: Create Emergency Alert & Role Guidance
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const relockHours = '${{ github.event.inputs.auto_relock_hours }}';
            const autoRelock = relockHours !== '0';
            const maintainer = '${{ github.event.inputs.maintainer_username }}';
            const userRole = '${{ needs.validate-user.outputs.user_role }}';
            const actor = '${{ github.actor }}';
            const owner = '${{ github.repository_owner }}';
            
            // Close any existing emergency issues
            const { data: existingEmergency } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: '${{ env.EMERGENCY_LABEL }}',
              state: 'open'
            });
            
            for (const issue of existingEmergency) {
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                state: 'closed',
                state_reason: 'completed'
              });
            }
            
            const reviewers = maintainer ? `@${owner} or @${maintainer}` : `@${owner}`;
            
            // Create high-priority emergency alert
            const { data: issue } = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: '🚨 CRITICAL: EMERGENCY ACCESS - PROTECTION DISABLED',
              body: `# 🚨 EMERGENCY ACCESS MODE ACTIVE
              
              ## ⚠️ CRITICAL SECURITY ALERT:
              **ALL REPOSITORY PROTECTION HAS BEEN TEMPORARILY DISABLED**
              
              ### Emergency unlocked by: @${actor} (${userRole})
              
              ### Current Dangerous State:
              - ❌ **NOname: Enhanced Repository Protection

on:
  workflow_dispatch:
    inputs:
      action:
        description: 'Protection action to perform'
        required: true
        type: choice
        options:
          - lock-it-down
          - remove-protection
          - emergency-unlock
          - status-check
      confirmation:
        description: 'Type "CONFIRM" to proceed (not needed for status-check)'
        required: false
        type: string
      approval_count:
        description: 'Required approvals (1-6)'
        required: true
        default: '2'
        type: choice
        options:
          - '1'
          - '2'
          - '3'
          - '4'
          - '5'
          - '6'
      bypass_admin:
        description: 'Allow admin bypass in emergencies?'
        required: true
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'
      auto_relock_hours:
        description: 'Auto re-lock after emergency unlock (hours, 0=manual)'
        required: true
        default: '24'
        type: choice
        options:
          - '0'
          - '1'
          - '4'
          - '8'
          - '24'
          - '72'

permissions:
  contents: write
  issues: write
  pull-requests: write
  administration: write

env:
  PROTECTION_LABEL: 'repo-protection-status'
  EMERGENCY_LABEL: '🚨-emergency-unlock'

jobs:
  validate-user:
    name: Validate Authorization
    runs-on: ubuntu-latest
    outputs:
      authorized: ${{ steps.check.outputs.authorized }}
      skip_confirmation: ${{ steps.check.outputs.skip_confirmation }}
    
    steps:
      - name: Check Authorization & Confirmation
        id: check
        run: |
          echo "🔍 Validating user authorization..."
          
          # Only repository owner can run destructive actions
          if [ "${{ github.actor }}" != "${{ github.repository_owner }}" ]; then
            echo "❌ UNAUTHORIZED: Only ${{ github.repository_owner }} can modify protection"
            echo "authorized=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Skip confirmation check for status-check action
          if [ "${{ github.event.inputs.action }}" = "status-check" ]; then
            echo "skip_confirmation=true" >> $GITHUB_OUTPUT
            echo "✅ Status check - no confirmation required"
            echo "authorized=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Require confirmation for destructive actions
          if [ "${{ github.event.inputs.confirmation }}" != "CONFIRM" ]; then
            echo "❌ INVALID: Must type 'CONFIRM' exactly for ${{ github.event.inputs.action }}"
            echo "authorized=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          echo "skip_confirmation=false" >> $GITHUB_OUTPUT
          echo "✅ Authorization validated for ${{ github.event.inputs.action }}"
          echo "authorized=true" >> $GITHUB_OUTPUT

  status-check:
    name: Check Protection Status
    runs-on: ubuntu-latest
    needs: validate-user
    if: needs.validate-user.outputs.authorized == 'true' && github.event.inputs.action == 'status-check'
    
    steps:
      - name: Check Current Protection
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            console.log('📊 Checking current protection status...');
            
            const branches = ['main', 'master'];
            const status = {
              protected_branches: [],
              unprotected_branches: [],
              codeowners_exists: false
            };
            
            // Check each branch
            for (const branch of branches) {
              try {
                const { data: protection } = await github.rest.repos.getBranchProtection({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  branch: branch
                });
                
                status.protected_branches.push({
                  branch,
                  required_reviews: protection.required_pull_request_reviews?.required_approving_review_count || 0,
                  code_owner_reviews: protection.required_pull_request_reviews?.require_code_owner_reviews,
                  force_push_blocked: !protection.allow_force_pushes,
                  deletion_blocked: !protection.allow_deletions
                });
                
              } catch (error) {
                if (error.status === 404) {
                  // Check if branch exists but is unprotected
                  try {
                    await github.rest.repos.getBranch({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      branch: branch
                    });
                    status.unprotected_branches.push(branch);
                  } catch (branchError) {
                    console.log(`ℹ️ Branch ${branch} does not exist`);
                  }
                }
              }
            }
            
            // Check for CODEOWNERS
            try {
              await github.rest.repos.getContent({
                owner: context.repo.owner,
                repo: context.repo.repo,
                path: '.github/CODEOWNERS'
              });
              status.codeowners_exists = true;
            } catch (error) {
              status.codeowners_exists = false;
            }
            
            // Create status report
            let statusEmoji = '🔴';
            let statusText = 'UNPROTECTED';
            
            if (status.protected_branches.length > 0) {
              statusEmoji = '🟢';
              statusText = 'PROTECTED';
            } else if (status.unprotected_branches.length > 0) {
              statusEmoji = '🟡';
              statusText = 'PARTIALLY PROTECTED';
            }
            
            const reportBody = `# ${statusEmoji} Repository Protection Status Report
            
            **Overall Status:** ${statusText}
            **Generated:** $(date)
            **Requested by:** @${{ github.actor }}
            
            ## 🛡️ Protected Branches
            ${status.protected_branches.length === 0 ? '*No branches are currently protected*' : 
              status.protected_branches.map(b => 
                `- **${b.branch}**: ${b.required_reviews} reviews, Code owner: ${b.code_owner_reviews ? '✅' : '❌'}, Force push: ${b.force_push_blocked ? '🚫' : '⚠️'}`
              ).join('\n')}
            
            ## ⚠️ Unprotected Branches  
            ${status.unprotected_branches.length === 0 ? '*All existing branches are protected*' :
              status.unprotected_branches.map(b => `- **${b}** - No protection rules`).join('\n')}
            
            ## 📋 CODEOWNERS File
            ${status.codeowners_exists ? '✅ Present' : '❌ Missing'}
            
            ## 🔧 Quick Actions
            To modify protection, run this workflow with:
            - **Lock down:** Action: \`lock-it-down\`, Confirmation: \`CONFIRM\`
            - **Remove protection:** Action: \`remove-protection\`, Confirmation: \`CONFIRM\`
            - **Emergency unlock:** Action: \`emergency-unlock\`, Confirmation: \`CONFIRM\`
            `;
            
            // Create or update status issue
            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: 'protection-status-report',
              state: 'open'
            });
            
            if (issues.length > 0) {
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issues[0].number,
                body: reportBody
              });
              console.log(`✅ Updated status report: #${issues[0].number}`);
            } else {
              const { data: newIssue } = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `${statusEmoji} Repository Protection Status Report`,
                body: reportBody,
                labels: ['protection-status-report', 'automated']
              });
              console.log(`✅ Created status report: #${newIssue.number}`);
            }

  apply-protection:
    name: Apply Strict Protection
    runs-on: ubuntu-latest
    needs: validate-user
    if: needs.validate-user.outputs.authorized == 'true' && github.event.inputs.action == 'lock-it-down'
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
        
      - name: Create Enhanced CODEOWNERS
        run: |
          echo "📝 Creating comprehensive CODEOWNERS file..."
          mkdir -p .github
          
          cat > .github/CODEOWNERS << 'EOF'
          # 🔒 COMPREHENSIVE REPOSITORY PROTECTION
          # All changes require maintainer approval - ZERO EXCEPTIONS
          # Generated automatically by GitHub Actions workflow
          
          # === GLOBAL PROTECTION ===
          # Every single file requires approval
          * @${{ github.repository_owner }}
          
          # === CRITICAL SYSTEM FILES ===
          # Extra vigilance for infrastructure
          /.github/ @${{ github.repository_owner }}
          /.github/workflows/ @${{ github.repository_owner }}
          /.github/CODEOWNERS @${{ github.repository_owner }}
          
          # Package management
          /package*.json @${{ github.repository_owner }}
          /yarn.lock @${{ github.repository_owner }}
          /pnpm-lock.yaml @${{ github.repository_owner }}
          /bun.lockb @${{ github.repository_owner }}
          
          # Configuration files
          /*.yml @${{ github.repository_owner }}
          /*.yaml @${{ github.repository_owner }}
          /*.json @${{ github.repository_owner }}
          /*.js @${{ github.repository_owner }}
          /*.mjs @${{ github.repository_owner }}
          /*.ts @${{ github.repository_owner }}
          /*.config.* @${{ github.repository_owner }}
          
          # Environment and secrets
          /.env* @${{ github.repository_owner }}
          /.env.* @${{ github.repository_owner }}
          /secrets/ @${{ github.repository_owner }}
          
          # Docker and deployment
          /Dockerfile* @${{ github.repository_owner }}
          /docker-compose*.yml @${{ github.repository_owner }}
          /.dockerignore @${{ github.repository_owner }}
          /kubernetes/ @${{ github.repository_owner }}
          /k8s/ @${{ github.repository_owner }}
          
          # === SOURCE CODE DIRECTORIES ===
          /src/ @${{ github.repository_owner }}
          /app/ @${{ github.repository_owner }}
          /components/ @${{ github.repository_owner }}
          /pages/ @${{ github.repository_owner }}
          /api/ @${{ github.repository_owner }}
          /lib/ @${{ github.repository_owner }}
          /utils/ @${{ github.repository_owner }}
          /helpers/ @${{ github.repository_owner }}
          /hooks/ @${{ github.repository_owner }}
          /context/ @${{ github.repository_owner }}
          /store/ @${{ github.repository_owner }}
          /redux/ @${{ github.repository_owner }}
          /services/ @${{ github.repository_owner }}
          /middleware/ @${{ github.repository_owner }}
          
          # Styling
          /styles/ @${{ github.repository_owner }}
          /css/ @${{ github.repository_owner }}
          /sass/ @${{ github.repository_owner }}
          /scss/ @${{ github.repository_owner }}
          
          # Assets and public files
          /public/ @${{ github.repository_owner }}
          /static/ @${{ github.repository_owner }}
          /assets/ @${{ github.repository_owner }}
          /images/ @${{ github.repository_owner }}
          
          # === TESTING AND CI/CD ===
          /test/ @${{ github.repository_owner }}
          /tests/ @${{ github.repository_owner }}
          /__tests__/ @${{ github.repository_owner }}
          /e2e/ @${{ github.repository_owner }}
          /cypress/ @${{ github.repository_owner }}
          /jest.config.* @${{ github.repository_owner }}
          /vitest.config.* @${{ github.repository_owner }}
          
          # === DOCUMENTATION ===
          /README.md @${{ github.repository_owner }}
          /docs/ @${{ github.repository_owner }}
          /documentation/ @${{ github.repository_owner }}
          /*.md @${{ github.repository_owner }}
          
          # === VERSION CONTROL ===
          /.gitignore @${{ github.repository_owner }}
          /.gitattributes @${{ github.repository_owner }}
          
          # === DATABASE & MIGRATIONS ===
          /migrations/ @${{ github.repository_owner }}
          /database/ @${{ github.repository_owner }}
          /db/ @${{ github.repository_owner }}
          /prisma/ @${{ github.repository_owner }}
          /schema/ @${{ github.repository_owner }}
          EOF
          
          git add .github/CODEOWNERS
          if git commit -m "🔒 Add comprehensive CODEOWNERS - require maintainer approval for ALL changes"; then
            git push
            echo "✅ CODEOWNERS file created and committed"
          else
            echo "ℹ️ CODEOWNERS file already exists and is up to date"
          fi
        
      - name: Apply Enhanced Branch Protection Rules
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const approvalCount = parseInt('${{ github.event.inputs.approval_count }}');
            const bypassAdmin = '${{ github.event.inputs.bypass_admin }}' === 'true';
            
            console.log(`🔒 Applying enhanced protection:`);
            console.log(`- Required approvals: ${approvalCount}`);
            console.log(`- Admin bypass: ${bypassAdmin ? 'ENABLED' : 'DISABLED'}`);
            
            const protectionConfig = {
              required_status_checks: {
                strict: true,
                contexts: [],
                checks: []
              },
              enforce_admins: !bypassAdmin,
              required_pull_request_reviews: {
                required_approving_review_count: approvalCount,
                dismiss_stale_reviews: true,
                require_code_owner_reviews: true,
                require_last_push_approval: true, // Enhanced: require approval after every push
                bypass_pull_request_allowances: {
                  users: [],
                  teams: [],
                  apps: []
                }
              },
              restrictions: null,
              required_linear_history: false,
              allow_force_pushes: false,
              allow_deletions: false,
              block_creations: false,
              required_conversation_resolution: true,
              lock_branch: false,
              allow_fork_syncing: true
            };
            
            const branches = ['main', 'master'];
            const protectedBranches = [];
            
            for (const branch of branches) {
              try {
                // Check if branch exists first
                await github.rest.repos.getBranch({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  branch: branch
                });
                
                // Apply protection
                await github.rest.repos.updateBranchProtection({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  branch: branch,
                  ...protectionConfig
                });
                
                protectedBranches.push(branch);
                console.log(`✅ ${branch.toUpperCase()} branch protection applied successfully`);
                
              } catch (error) {
                if (error.status === 404) {
                  console.log(`ℹ️ ${branch} branch does not exist, skipping`);
                } else {
                  console.error(`❌ Failed to protect ${branch} branch:`, error.message);
                }
              }
            }
            
            if (protectedBranches.length === 0) {
              throw new Error('No branches were protected! Please ensure main or master branch exists.');
            }
            
            console.log(`🛡️ Successfully protected ${protectedBranches.length} branch(es): ${protectedBranches.join(', ')}`);
        
      - name: Schedule Auto-Relock (if emergency unlock is used)
        if: github.event.inputs.auto_relock_hours != '0'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // This would create a reminder issue for manual re-locking
            // In a real scenario, you might use GitHub's scheduled workflows
            const hours = '${{ github.event.inputs.auto_relock_hours }}';
            console.log(`⏰ Auto-relock configured for ${hours} hours after emergency unlock`);
            console.log('ℹ️ Note: Auto-relock requires manual workflow trigger in current implementation');

      - name: Create Protection Status Issue
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const approvalCount = '${{ github.event.inputs.approval_count }}';
            const bypassAdmin = '${{ github.event.inputs.bypass_admin }}' === 'true';
            
            // Close existing protection status issues
            const { data: existingIssues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: '${{ env.PROTECTION_LABEL }}',
              state: 'open'
            });
            
            for (const issue of existingIssues) {
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                state: 'closed',
                state_reason: 'completed'
              });
            }
            
            // Create comprehensive protection status issue
            const { data: issue } = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: '🛡️ Repository Protection Status - MAXIMUM SECURITY ACTIVE',
              body: `# 🔒 MAXIMUM REPOSITORY PROTECTION ACTIVE
              
              This repository is now under **MAXIMUM SECURITY PROTECTION**.
              
              ## 🛡️ Current Protection Configuration:
              - **${approvalCount} required approvals** for any PR to protected branches
              - **Code owner approval** mandatory (@${{ github.repository_owner }})
              - **Last-push approval** required (new commits need fresh approval)
              - **All conversations** must be resolved before merge
              - **Stale reviews** automatically dismissed on new commits
              - **Force pushes** completely blocked on protected branches
              - **Branch deletion** blocked for main/master
              - **Direct pushes** to main/master completely blocked
              - **Admin bypass**: ${bypassAdmin ? '⚠️ ENABLED (emergency only)' : '🚫 DISABLED'}
              
              ## ❌ What Contributors CANNOT Do:
              - Push directly to main or master branch
              - Merge their own pull requests
              - Merge without required approvals
              - Force push to any protected branch
              - Delete protected branches
              - Bypass code owner review requirements
              - Merge with unresolved conversations
              - Use stale approvals after pushing new commits
              
              ## ✅ What Contributors CAN Do:
              - Create feature branches (including issue-* branches)
              - Open pull requests from their branches
              - Push commits to their own feature branches
              - Participate in code reviews and discussions
              - Comment and suggest changes
              - Resolve conversations
              
              ## 🔄 Workflow Compatibility Status:
              - ✅ Issue branch creation workflows remain functional
              - ✅ External contributor messaging systems work
              - ✅ PR merge celebrations and notifications work
              - ✅ Automated branch cleanup works
              - ✅ All existing CI/CD automations remain functional
              - ✅ Dependabot and security updates work (if configured)
              
              ## 🚨 Emergency Procedures:
              
              ### Temporary Unlock (Emergencies Only):
              1. Run **Strict Repository Protection** workflow
              2. Select Action: \`emergency-unlock\`
              3. Enter Confirmation: \`CONFIRM\`
              4. Complete emergency changes IMMEDIATELY
              5. Re-enable protection using \`lock-it-down\`
              
              ### Status Checking:
              Run workflow with Action: \`status-check\` (no confirmation needed)
              
              ## 📊 Protection Summary:
              | Setting | Status |
              |---------|---------|
              | **Protection Level** | 🔴 MAXIMUM |
              | **Required Approvals** | ${approvalCount} |
              | **Code Owner Review** | ✅ Required |
              | **Last Push Approval** | ✅ Required |
              | **Admin Bypass** | ${bypassAdmin ? '⚠️ Enabled' : '🚫 Disabled'} |
              | **Force Push** | 🚫 Blocked |
              | **Direct Push** | 🚫 Blocked |
              | **Branch Deletion** | 🚫 Blocked |
              | **Conversation Resolution** | ✅ Required |
              
              ---
              **Protection activated by:** @${{ github.actor }}  
              **Activation time:** $(date)  
              **Configuration:** ${approvalCount} approvals, Admin bypass ${bypassAdmin ? 'ON' : 'OFF'}
              
              *To modify protection settings, run the workflow again with different parameters*`,
              labels: ['${{ env.PROTECTION_LABEL }}', 'security', 'automated', 'max-protection']
            });
            
            // Pin the issue for visibility
            console.log(`✅ Protection status issue created: #${issue.number}`);

  emergency-unlock:
    name: Emergency Unlock
    runs-on: ubuntu-latest
    needs: validate-user
    if: needs.validate-user.outputs.authorized == 'true' && github.event.inputs.action == 'emergency-unlock'
    
    steps:
      - name: Emergency Protection Disable
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            console.log('🚨 EMERGENCY: Disabling all protection immediately...');
            
            const branches = ['main', 'master'];
            const unlockedBranches = [];
            
            for (const branch of branches) {
              try {
                await github.rest.repos.deleteBranchProtection({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  branch: branch
                });
                unlockedBranches.push(branch);
                console.log(`🚨 EMERGENCY: ${branch} protection DISABLED`);
              } catch (error) {
                if (error.status === 404) {
                  console.log(`ℹ️ ${branch} was not protected`);
                } else {
                  console.warn(`⚠️ Could not disable ${branch} protection:`, error.message);
                }
              }
            }
            
            if (unlockedBranches.length === 0) {
              console.log('ℹ️ No protected branches found to unlock');
            } else {
              console.log(`🚨 EMERGENCY COMPLETE: ${unlockedBranches.length} branch(es) unlocked`);
            }

      - name: Create Emergency Alert & Schedule Relock
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const relockHours = '${{ github.event.inputs.auto_relock_hours }}';
            const autoRelock = relockHours !== '0';
            
            // Close any existing emergency issues
            const { data: existingEmergency } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: '${{ env.EMERGENCY_LABEL }}',
              state: 'open'
            });
            
            for (const issue of existingEmergency) {
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                state: 'closed',
                state_reason: 'completed'
              });
            }
            
            // Create high-priority emergency alert
            const { data: issue } = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: '🚨 CRITICAL: EMERGENCY ACCESS - PROTECTION DISABLED',
              body: `# 🚨 EMERGENCY ACCESS MODE ACTIVE
              
              ## ⚠️ CRITICAL SECURITY ALERT:
              **ALL REPOSITORY PROTECTION HAS BEEN TEMPORARILY DISABLED**
              
              ### Current Dangerous State:
              - ❌ **NO approval requirements** for any changes
              - ❌ **Direct pushes** to main/master branches ALLOWED
              - ❌ **Force pushes** currently ALLOWED
              - ❌ **Branch deletion** currently ALLOWED
              - ❌ **No code owner protection** active
              - ❌ **No conversation resolution** required
              
              ## 🔥 IMMEDIATE ACTIONS REQUIRED:
              
              ### 1. Complete Emergency Work ASAP
              - Make your critical changes **RIGHT NOW**
              - Keep emergency window as short as possible
              - Document what you're changing and why
              
              ### 2. Re-Enable Protection ${autoRelock ? `(Auto-scheduled in ${relockHours}h)` : '(MANUAL ACTION REQUIRED)'}
              **Run the protection workflow again:**
              - Action: \`lock-it-down\`
              - Confirmation: \`CONFIRM\`
              - Set appropriate approval count
              - Choose admin bypass setting
              
              ${autoRelock ? `### ⏰ Auto-Relock Scheduled
              Protection will be automatically suggested for re-enabling in **${relockHours} hours**.
              You will receive a reminder issue at that time.
              
              **Manual re-enabling before ${relockHours}h is STRONGLY RECOMMENDED.**` : '### ⚠️ Manual Re-Lock Required
              **No automatic re-locking is scheduled.**
              **YOU MUST MANUALLY RE-ENABLE PROTECTION!**'}
              
              ## 📝 Emergency Log:
              - **Emergency triggered by:** @${{ github.actor }}
              - **Time:** $(date)
              - **Reason:** Emergency unlock requested
              - **Auto-relock:** ${autoRelock ? `${relockHours} hours` : 'Manual only'}
              
              ## 🔔 Security Reminders:
              - **Monitor the repository** closely during this period
              - **Limit emergency changes** to only what's absolutely necessary
              - **Re-enable protection** as soon as emergency work is complete
              - **Review all changes** made during emergency period
              
              ---
              **🚨 THIS ISSUE WILL REMAIN OPEN UNTIL PROTECTION IS RE-ENABLED 🚨**`,
              labels: ['${{ env.EMERGENCY_LABEL }}', 'critical', 'security-alert', 'action-required']
            });
            
            console.log(`🚨 Emergency alert created: #${issue.number}`);
            
            // If auto-relock is enabled, create a reminder issue
            if (autoRelock) {
              const relockTime = new Date();
              relockTime.setHours(relockTime.getHours() + parseInt(relockHours));
              
              console.log(`⏰ Auto-relock reminder scheduled for ${relockTime.toISOString()}`);
              console.log('ℹ️ Note: Actual auto-relock requires additional workflow implementation');
            }

  create-pr-guidelines:
    name: Create PR Review Guidelines  
    runs-on: ubuntu-latest
    needs: [validate-user, apply-protection]
    if: needs.validate-user.outputs.authorized == 'true' && github.event.inputs.action == 'lock-it-down'
    
    steps:
      - name: Create PR Review Guidelines Issue
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const maintainer = '${{ github.event.inputs.maintainer_username }}';
            const owner = '${{ github.repository_owner }}';
            const approvalCount = parseInt('${{ github.event.inputs.approval_count }}');
            
            const reviewers = maintainer ? `@${owner} and @${maintainer}` : `@${owner}`;
            const reviewerCount = maintainer ? 2 : 1;
            
            // Close existing PR guidelines issues
            const { data: existingGuidelines } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: 'pr-review-guidelines',
              state: 'open'
            });
            
            for (const issue of existingGuidelines) {
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                state: 'closed',
                state_reason: 'completed'
              });
            }
            
            const { data: issue } = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: '📝 Pull Request Review Guidelines - Required Reading',
              body: `# 📝 Pull Request Review & Approval Guidelines
              
              ## 🎯 **Current Review Requirements:**
              - **${approvalCount} approvals required** for any PR to main/master
              - **Authorized reviewers:** ${reviewers}
              - **Code owner approval:** Always required
              - **All conversations must be resolved** before merge
              
              ---
              
              ## 👥 **For Contributors - How to Get Your PR Approved:**
              
              ### ✅ **Before Opening a PR:**
              1. **Test your changes** thoroughly
              2. **Write clear commit messages**
              3. **Update documentation** if needed
              4. **Check for merge conflicts**
              5. **Follow project coding standards**
              
              ### 📋 **PR Description Template:**
              \`\`\`markdown
              ## What does this PR do?
              Brief description of changes...
              
              ## Why is this change needed?
              Explanation of the problem being solved...
              
              ## How was this tested?
              - [ ] Manual testing
              - [ ] Unit tests added/updated
              - [ ] Integration tests pass
              
              ## Screenshots (if UI changes):
              [Add screenshots here]
              
              ## Checklist:
              - [ ] Code follows project standards
              - [ ] Tests added/updated
              - [ ] Documentation updated
              - [ ] No merge conflicts
              - [ ] Ready for review
              \`\`\`
              
              ### 🔄 **After Opening a PR:**
              1. **Request reviews** from ${reviewers}
              2. **Respond to feedback** promptly and respectfully  
              3. **Make requested changes** and push updates
              4. **Resolve conversations** after addressing comments
              5. **Be patient** - thorough reviews take time!
              
              ---
              
              ## 🔍 **For Reviewers (${reviewers}) - Review Standards:**
              
              ### 🛡️ **Security Review Checklist:**
              - [ ] **Dependencies:** No suspicious or vulnerable packages
              - [ ] **Environment variables:** No secrets exposed in code
              - [ ] **File permissions:** Appropriate access controls
              - [ ] **Input validation:** User inputs properly sanitized
              - [ ] **Authentication:** Proper access controls maintained
              
              ### 💻 **Code Quality Review:**
              - [ ] **Functionality:** Code does what it claims to do
              - [ ] **Performance:** No obvious performance issues
              - [ ] **Maintainability:** Code is readable and well-structured
              - [ ] **Testing:** Adequate test coverage
              - [ ] **Documentation:** Changes are properly documented
              
              ### 🏗️ **Architecture Review:**
              - [ ] **Design patterns:** Follows established project patterns
              - [ ] **Dependencies:** Minimal and justified dependencies
              - [ ] **Backwards compatibility:** Doesn't break existing functionality
              - [ ] **Future impact:** Consider long-term maintenance
              
              ### 📝 **Review Process:**
              1. **Assign yourself** to the PR
              2. **Review code thoroughly** - don't rush
              3. **Test changes locally** if possible
              4. **Leave constructive feedback** with specific suggestions
              5. **Approve when satisfied** or request changes with clear guidance
              
              ---
              
              ## 🚦 **Approval Workflow:**
              
              ### For Standard Changes:
              - **${approvalCount} approvals needed** from authorized reviewers
              - **All conversations resolved**
              - **CI/CD checks passed** (if configured)
              - **No merge conflicts**
              
              ### For Critical Changes (configs, security, infrastructure):
              ${maintainer ? `- **Both @${owner} AND @${maintainer} must approve**
              - **Extra thorough testing** required
              - **Documentation updates** mandatory` : `- **@${owner} must personally review and approve**
              - **Extra thorough testing** required  
              - **Clear documentation** of impact`}
              - **Consider staging deployment** first
              
              ### Emergency Changes:
              - **Emergency unlock** may be used for critical fixes
              - **Document thoroughly** in emergency issue
              - **Re-enable protection** immediately after
              - **Post-emergency review** required
              
              ---
              
              ## 💡 **Tips for Smooth Reviews:**
              
              ### For Contributors:
              - 🎯 **Keep PRs focused** - one feature/fix per PR
              - 📝 **Write descriptive titles** and descriptions
              - 🧪 **Include tests** for new functionality
              - 💬 **Be responsive** to reviewer feedback
              - 🙏 **Be respectful** and open to suggestions
              
              ### For Reviewers:
              - ⏱️ **Review promptly** - don't let PRs languish
              - 🎨 **Focus on important issues** - not just style nitpicks
              - 💡 **Suggest solutions** not just problems
              - ✅ **Acknowledge good work** when you see it
              - 📚 **Help contributors learn** through constructive feedback
              
              ---
              
              ## 🚨 **Common Issues & Solutions:**
              
              ### "My PR is stuck waiting for approval"
              - ✅ Tag reviewers: ${reviewers}
              - ✅ Check if all conversations are resolved
              - ✅ Ensure CI checks are passing
              - ✅ Make sure PR description is clear
              
              ### "I disagree with reviewer feedback"
              - 💬 **Discuss respectfully** in PR comments
              - 🤝 **Seek compromise** solutions
              - 📞 **Escalate to @${owner}** if needed
              - 🎯 **Focus on the goal** - improving code quality
              
              ### "Review is taking too long"
              - ⏱️ **Reviewers aim for 24-48 hour response**
              - 🏷️ **Use appropriate labels** for urgency
              - 💬 **Polite follow-up** after reasonable wait time
              - 🚨 **Emergency process** for critical fixes only
              
              ---
              
              ## 📊 **Review Statistics & Goals:**
              
              **Target Metrics:**
              - ⏱️ **Review response time:** < 48 hours
              - 🔄 **Back-and-forth rounds:** < 3 iterations  
              - ✅ **Approval rate:** High (indicates good PR quality)
              - 🚀 **Merge time:** < 1 week for standard changes
              
              **Quality Indicators:**
              - 🐛 **Post-merge bugs:** Minimal
              - 🔒 **Security issues:** Zero tolerance
              - 📈 **Code coverage:** Maintained or improved
              - 📚 **Documentation:** Up to date
              
              ---
              
              *This is a living document - suggest improvements by commenting below or opening an issue!*
              
              **Questions? Tag ${reviewers} for clarification.**`,
              labels: ['pr-review-guidelines', 'documentation', 'process', 'pinned'],
              assignees: maintainer ? [owner, maintainer] : [owner]
            });
            
            // Pin the issue or add to project if available
            console.log(`📝 PR Review Guidelines created: #${issue.number}`);
            
            // Add comment with quick links
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              body: `## 🔗 Quick Links & Resources
              
              ### 📋 **Templates & Examples:**
              - **PR Description Template:** Copy from main issue above ☝️
              - **Good PR Examples:** [Browse recent merged PRs](${context.payload.repository.html_url}/pulls?q=is%3Apr+is%3Amerged)
              - **Code Style Guide:** [Check repository documentation](${context.payload.repository.html_url}/tree/main/docs)
              
              ### ⚡ **Quick Actions:**
              - **Check Protection Status:** [View current protection](${context.payload.repository.html_url}/actions/workflows/enhanced-protection.yml)
              - **Review Pending PRs:** [Open pull requests](${context.payload.repository.html_url}/pulls)
              - **Emergency Access:** Only for ${reviewers}
              
              ### 💬 **Communication:**
              - **Questions about reviews:** Comment on specific PR
              - **Process suggestions:** Comment on this issue
              - **Urgent issues:** Tag ${reviewers} directly
              
              **Bookmark this issue for reference! 🔖**`
            );

  remove-protection:
    name: Remove All Protection
    runs-on: ubuntu-latest
    needs: validate-user
    if: needs.validate-user.outputs.authorized == 'true' && github.event.inputs.action == 'remove-protection'
    
    steps:
      - name: Remove All Branch Protection
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            console.log('🔓 Permanently removing all branch protection...');
            
            const branches = ['main', 'master'];
            const removedProtection = [];
            
            for (const branch of branches) {
              try {
                await github.rest.repos.deleteBranchProtection({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  branch: branch
                });
                removedProtection.push(branch);
                console.log(`✅ ${branch} protection permanently removed`);
              } catch (error) {
                if (error.status === 404) {
                  console.log(`ℹ️ ${branch} branch was not protected`);
                } else {
                  console.warn(`⚠️ Could not remove ${branch} protection:`, error.message);
                }
              }
            }
            
            console.log(`🔓 Protection removed from ${removedProtection.length} branch(es)`);
            
      - name: Remove CODEOWNERS File
        run: |
          if [ -f ".github/CODEOWNERS" ]; then
            echo "🗑️ Removing CODEOWNERS file..."
            git rm .github/CODEOWNERS
            git commit -m "🔓 Remove CODEOWNERS - protection permanently disabled"
            git push
            echo "✅ CODEOWNERS file removed"
          else
            echo "ℹ️ CODEOWNERS file does not exist"
          fi
      
      - name: Create Removal Confirmation
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // Close all protection-related issues
            const protectionLabels = ['${{ env.PROTECTION_LABEL }}', '${{ env.EMERGENCY_LABEL }}', 'protection-status-report'];
            
            for (const label of protectionLabels) {
              const { data: issues } = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                labels: label,
                state: 'open'
              });
              
              for (const issue of issues) {
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  state: 'closed',
                  state_reason: 'completed'
                });
              }
            }
            
            // Create permanent removal notification
            const { data: issue } = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: '🔓 Repository Protection PERMANENTLY REMOVED',
              body: `# 🔓 ALL REPOSITORY PROTECTION DISABLED
              
              **All repository protection rules have been PERMANENTLY REMOVED.**
              
              ## ⚠️ CURRENT DANGEROUS STATE:
              - ❌ **No approval requirements** for any pull requests
              - ❌ **No code owner protection** active
              - ❌ **Direct pushes** to main/master branches ALLOWED
              - ❌ **Force pushes** completely ALLOWED
              - ❌ **Branch deletion** completely ALLOWED  
              - ❌ **No conversation resolution** required
              - ❌ **CODEOWNERS file** has been removed
              
              ## 🚨 SECURITY IMPLICATIONS:
              Anyone with write access to this repository can now:
              - Push directly to the main branch (bypassing reviews)
              - Force push and rewrite commit history
              - Delete any branches including main/master
              - Merge pull requests without any approvals
              - Make changes without code owner oversight
              
              ## 📋 What Was Removed:
              - All branch protection rules
              - CODEOWNERS file requirements  
              - Pull request review requirements
              - Force push restrictions
              - Branch deletion restrictions
              - Conversation resolution requirements
              
              ## 🔄 Re-Enabling Protection:
              To restore protection at any time, run the **Enhanced Repository Protection** workflow:
              - Action: \`lock-it-down\`
              - Confirmation: \`CONFIRM\`
              - Choose desired approval count (1-6)
              - Configure admin bypass setting
              
              ## 📊 Repository Status: 🔴 COMPLETELY UNPROTECTED
              
              **⚠️ RECOMMENDATION: Consider re-enabling protection unless you specifically need an unprotected repository.**
              
              ---
              **Protection removed by:** @${{ github.actor }}  
              **Removal time:** $(date)  
              **Previous protection:** Completely disabled
              
              *This repository is now in an unprotected state. Exercise caution with all changes.*`,
              labels: ['security-warning', 'unprotected', 'permanent-removal']
            });
            
            console.log(`🔓 Removal confirmation created: #${issue.number}`);

  verify-protection:
    name: Verify Protection Status
    runs-on: ubuntu-latest
    needs: [validate-user, apply-protection]
    if: needs.validate-user.outputs.authorized == 'true' && github.event.inputs.action == 'lock-it-down' && always()
    
    steps:
      - name: Comprehensive Protection Verification
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            console.log('🔍 Running comprehensive protection verification...');
            
            const approvalCount = parseInt('${{ github.event.inputs.approval_count }}');
            const bypassAdmin = '${{ github.event.inputs.bypass_admin }}' === 'true';
            const branches = ['main', 'master'];
            const verificationResults = [];
            
            for (const branch of branches) {
              try {
                const { data: protection } = await github.rest.repos.getBranchProtection({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  branch: branch
                });
                
                const result = {
                  branch,
                  protected: true,
                  required_reviews: protection.required_pull_request_reviews?.required_approving_review_count || 0,
                  code_owner_required: protection.required_pull_request_reviews?.require_code_owner_reviews || false,
                  last_push_approval: protection.required_pull_request_reviews?.require_last_push_approval || false,
                  dismiss_stale: protection.required_pull_request_reviews?.dismiss_stale_reviews || false,
                  force_push_blocked: !protection.allow_force_pushes,
                  deletion_blocked: !protection.allow_deletions,
                  conversation_resolution: protection.required_conversation_resolution || false,
                  admin_enforcement: protection.enforce_admins || false
                };
                
                verificationResults.push(result);
                
                // Verify configuration matches expectations
                const issues = [];
                if (result.required_reviews !== approvalCount) {
                  issues.push(`Expected ${approvalCount} reviews, got ${result.required_reviews}`);
                }
                if (!result.code_owner_required) {
                  issues.push('Code owner reviews not required');
                }
                if (!result.last_push_approval) {
                  issues.push('Last push approval not required');
                }
                if (!result.dismiss_stale) {
                  issues.push('Stale review dismissal not enabled');
                }
                if (!result.force_push_blocked) {
                  issues.push('Force pushes not blocked');
                }
                if (!result.deletion_blocked) {
                  issues.push('Branch deletion not blocked');
                }
                if (!result.conversation_resolution) {
                  issues.push('Conversation resolution not required');
                }
                if (result.admin_enforcement === bypassAdmin) {
                  issues.push(`Admin enforcement mismatch (expected ${!bypassAdmin})`);
                }
                
                if (issues.length === 0) {
                  console.log(`✅ ${branch.toUpperCase()} branch protection verification PASSED`);
                } else {
                  console.log(`⚠️ ${branch.toUpperCase()} branch protection issues found:`);
                  issues.forEach(issue => console.log(`  - ${issue}`));
                }
                
                console.log(`📊 ${branch.toUpperCase()} Protection Summary:`);
                console.log(`  - Required Reviews: ${result.required_reviews}/${approvalCount} ✅`);
                console.log(`  - Code Owner Reviews: ${result.code_owner_required ? '✅' : '❌'}`);
                console.log(`  - Last Push Approval: ${result.last_push_approval ? '✅' : '❌'}`);
                console.log(`  - Dismiss Stale Reviews: ${result.dismiss_stale ? '✅' : '❌'}`);
                console.log(`  - Force Pushes Blocked: ${result.force_push_blocked ? '✅' : '❌'}`);
                console.log(`  - Branch Deletion Blocked: ${result.deletion_blocked ? '✅' : '❌'}`);
                console.log(`  - Conversation Resolution: ${result.conversation_resolution ? '✅' : '❌'}`);
                console.log(`  - Admin Enforcement: ${result.admin_enforcement ? '✅' : '❌'} (bypass ${bypassAdmin ? 'enabled' : 'disabled'})`);
                
              } catch (error) {
                if (error.status === 404) {
                  console.log(`ℹ️ ${branch} branch not found or not protected`);
                } else {
                  console.error(`❌ Failed to verify ${branch} protection:`, error.message);
                  throw error;
                }
              }
            }
            
            // Check for CODEOWNERS file
            try {
              const { data: codeowners } = await github.rest.repos.getContent({
                owner: context.repo.owner,
                repo: context.repo.repo,
                path: '.github/CODEOWNERS'
              });
              console.log('✅ CODEOWNERS file verification PASSED');
              
              // Decode and check content
              const content = Buffer.from(codeowners.content, 'base64').toString();
              if (content.includes(`@${context.repo.owner}`)) {
                console.log('✅ CODEOWNERS contains repository owner');
              } else {
                console.log('⚠️ CODEOWNERS may not contain repository owner');
              }
              
            } catch (error) {
              console.error('❌ CODEOWNERS file verification FAILED:', error.message);
              throw new Error('CODEOWNERS file missing or inaccessible');
            }
            
            // Summary
            const protectedCount = verificationResults.filter(r => r.protected).length;
            if (protectedCount > 0) {
              console.log(`🛡️ VERIFICATION COMPLETE: ${protectedCount} branch(es) successfully protected`);
              console.log('🔒 Repository protection is ACTIVE and verified!');
            } else {
              throw new Error('❌ VERIFICATION FAILED: No branches are protected!');
            }

  cleanup-old-issues:
    name: Cleanup Old Issues
    runs-on: ubuntu-latest
    needs: validate-user
    if: needs.validate-user.outputs.authorized == 'true' && always()
    
    steps:
      - name: Clean Up Outdated Protection Issues
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            console.log('🧹 Cleaning up outdated protection issues...');
            
            const labelsToCleanup = [
              'protection-status', // Legacy label
              'automated',
              'security'
            ];
            
            let cleanedCount = 0;
            
            for (const label of labelsToCleanup) {
              try {
                const { data: issues } = await github.rest.issues.listForRepo({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  labels: label,
                  state: 'open'
                });
                
                // Close issues older than current action (keep only latest)
                const oldIssues = issues.filter(issue => {
                  const issueAge = (Date.now() - new Date(issue.created_at).getTime()) / (1000 * 60); // minutes
                  return issueAge > 5; // Older than 5 minutes
                });
                
                for (const issue of oldIssues) {
                  // Skip if it's the current protection status or emergency alert
                  if (issue.labels.some(l => 
                    l.name === '${{ env.PROTECTION_LABEL }}' || 
                    l.name === '${{ env.EMERGENCY_LABEL }}' ||
                    l.name === 'protection-status-report'
                  )) {
                    continue;
                  }
                  
                  await github.rest.issues.update({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    state: 'closed',
                    state_reason: 'not_planned'
                  });
                  
                  cleanedCount++;
                }
                
              } catch (error) {
                console.warn(`⚠️ Could not cleanup issues with label ${label}:`, error.message);
              }
            }
            
            console.log(`🧹 Cleanup complete: ${cleanedCount} outdated issue(s) closed`);

  notify-completion:
    name: Notify Completion
    runs-on: ubuntu-latest
    needs: [validate-user, apply-protection, remove-protection, emergency-unlock, status-check]
    if: needs.validate-user.outputs.authorized == 'true' && always()
    
    steps:
      - name: Send Completion Summary
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const action = '${{ github.event.inputs.action }}';
            const actor = '${{ github.actor }}';
            const runUrl = `${context.payload.repository.html_url}/actions/runs/${context.runId}`;
            
            let emoji, title, message;
            
            switch(action) {
              case 'lock-it-down':
                emoji = '🔒';
                title = 'Repository Locked Down';
                message = 'Maximum security protection has been applied to the repository.';
                break;
              case 'remove-protection':
                emoji = '🔓'; 
                title = 'Protection Removed';
                message = 'All repository protection has been permanently removed.';
                break;
              case 'emergency-unlock':
                emoji = '🚨';
                title = 'Emergency Unlock Complete';
                message = 'Repository protection temporarily disabled for emergency access.';
                break;
              case 'status-check':
                emoji = '📊';
                title = 'Status Check Complete';
                message = 'Repository protection status has been analyzed and reported.';
                break;
              default:
                emoji = '✅';
                title = 'Workflow Complete';
                message = 'Repository protection workflow completed successfully.';
            }
            
            console.log(`${emoji} ${title}`);
            console.log(`Action: ${action}`);
            console.log(`Executed by: ${actor}`);
            console.log(`Run URL: ${runUrl}`);
            console.log(`Message: ${message}`);
            
            // The actual notification would be sent here
            // (email, Slack, Discord, etc. depending on your setup)
            }
            
            // Create emergency alert issue
            const { data: issue } = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: '🚨 EMERGENCY: Protection Temporarily Disabled',
              body: `# 🚨 EMERGENCY ACCESS GRANTED
              
              Repository protection has been **TEMPORARILY DISABLED** for emergency access.
              
              ## ⚠️ CRITICAL SECURITY ALERT:
              - **All protection rules** are currently OFF
              - **Direct pushes** to main/master are now allowed
              - **No approvals** required for changes
              - **Force pushes** are currently allowed
              
              ## 🔄 IMMEDIATE ACTION REQUIRED:
              1. **Complete your emergency changes IMMEDIATELY**
              2. **Re-enable protection** by running this workflow again:
                 - Action: \`lock-it-down\`
                 - Confirmation: \`CONFIRM\`
                 - Set appropriate approval count
              
              ## ⏰ AUTO-REMINDER:
              This issue will remain open as a reminder to **RE-ENABLE PROTECTION**.
              
              **Do not leave the repository unprotected longer than necessary!**
              
              ---
              *Emergency access granted by @${{ github.actor }} on $(date)*
              *Please re-enable protection as soon as emergency changes are complete*`,
              labels: ['🚨 EMERGENCY', 'security-alert', 'temporary', 'action-required']
            });
            
            console.log(`🚨 Emergency alert issue created: #${issue.number}`);

  verify-protection:
    name: Verify Protection Status
    runs-on: ubuntu-latest
    needs: [validate-user, apply-protection]
    if: needs.validate-user.outputs.authorized == 'true' && github.event.inputs.action == 'lock-it-down' && always()
    
    steps:
      - name: Verify Protection Applied
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            console.log('🔍 Verifying protection status...');
            
            try {
              const { data: protection } = await github.rest.repos.getBranchProtection({
                owner: context.repo.owner,
                repo: context.repo.repo,
                branch: 'main'
              });
              
              console.log('✅ Branch Protection Verification:');
              console.log('- Pull Request Reviews:', protection.required_pull_request_reviews ? '✅ ENABLED' : '❌ DISABLED');
              console.log('- Required Approvals:', protection.required_pull_request_reviews?.required_approving_review_count || 0);
              console.log('- Code Owner Reviews:', protection.required_pull_request_reviews?.require_code_owner_reviews ? '✅ ENABLED' : '❌ DISABLED');
              console.log('- Force Pushes Blocked:', !protection.allow_force_pushes ? '✅ BLOCKED' : '❌ ALLOWED');
              console.log('- Branch Deletion Blocked:', !protection.allow_deletions ? '✅ BLOCKED' : '❌ ALLOWED');
              console.log('- Conversation Resolution Required:', protection.required_conversation_resolution ? '✅ REQUIRED' : '❌ NOT REQUIRED');
              
              console.log('🛡️ Repository protection is ACTIVE and verified!');
              
            } catch (error) {
              console.error('❌ Protection verification failed:', error.message);
              throw error;
            }
