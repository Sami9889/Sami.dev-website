name: Enhanced Repository Protection

on:
  workflow_dispatch:
    inputs:
      action:
        description: 'Protection action to perform'
        required: true
        type: choice
        options: [lock-it-down, remove-protection, emergency-unlock, status-check]
      confirmation:
        description: 'Type "CONFIRM" to proceed (not needed for status-check)'
        required: false
        type: string
      approval_count:
        description: 'Required approvals (1-6)'
        required: true
        default: '2'
        type: choice
        options: ['1','2','3','4','5','6']
      bypass_admin:
        description: 'Allow admin bypass in emergencies?'
        required: true
        default: 'false'
        type: choice
        options: ['true','false']
      maintainer_username:
        description: 'Additional maintainer GitHub username (optional)'
        required: false
        type: string

  schedule:
    - cron: '0 2 * * *'
  
  issue_comment:
    types: [created]
  
  pull_request:
    types: [opened, synchronize, reopened]
  
  push:
    branches:
      - main
      - master

permissions:
  contents: write
  issues: write
  pull-requests: write
  actions: read
  security-events: write

env:
  PROTECTION_LABEL: 'repo-protection-status'
  EMERGENCY_LABEL: 'emergency-unlock'

jobs:
  validate-user:
    runs-on: ubuntu-latest
    outputs:
      authorized: ${{ steps.check.outputs.authorized }}
      user_role: ${{ steps.check.outputs.user_role }}
    steps:
      - name: Validate user permissions
        id: check
        run: |
          maintainer="${{ github.event.inputs.maintainer_username }}"
          
          if [ -z "$maintainer" ]; then
            maintainer="NONE_SET"
          fi
          
          if [ "${{ github.actor }}" != "${{ github.repository_owner }}" ] && [ "${{ github.actor }}" != "$maintainer" ]; then
            echo "authorized=false" >> $GITHUB_OUTPUT
            echo "user_role=unauthorized" >> $GITHUB_OUTPUT
            echo "::error::User ${{ github.actor }} is not authorized"
            exit 1
          fi
          
          if [ "${{ github.actor }}" == "${{ github.repository_owner }}" ]; then
            echo "user_role=owner" >> $GITHUB_OUTPUT
          else
            echo "user_role=maintainer" >> $GITHUB_OUTPUT
          fi
          echo "authorized=true" >> $GITHUB_OUTPUT

  cleanup-old-branches:
    needs: validate-user
    if: needs.validate-user.outputs.authorized == 'true' && github.event_name == 'schedule'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Delete old branches
        run: |
          git fetch --prune origin
          
          branches=$(git branch -r | grep -v "HEAD\|main\|master" | sed 's/origin\///' || true)
          
          if [ -z "$branches" ]; then
            echo "No branches to process"
            exit 0
          fi
          
          echo "$branches" | while IFS= read -r branch; do
            branch=$(echo "$branch" | xargs)
            
            if [ -z "$branch" ]; then
              continue
            fi
            
            if git rev-parse --verify "origin/$branch" >/dev/null 2>&1; then
              last_commit=$(git log -1 --format=%at "origin/$branch" 2>/dev/null || echo "0")
              current_time=$(date +%s)
              days_old=$(( ($current_time - $last_commit) / 86400 ))
              
              if [ $days_old -gt 30 ]; then
                echo "Deleting old branch: $branch (${days_old} days old)"
                git push origin --delete "$branch" || echo "Failed to delete $branch"
              else
                echo "Branch $branch is only $days_old days old, keeping"
              fi
            else
              echo "Branch $branch no longer exists, skipping"
            fi
          done

  apply-protection:
    needs: validate-user
    if: |
      needs.validate-user.outputs.authorized == 'true' && 
      github.event.inputs.action == 'lock-it-down'
    runs-on: ubuntu-latest
    steps:
      - name: Validate confirmation
        run: |
          if [ "${{ github.event.inputs.confirmation }}" != "CONFIRM" ]; then
            echo "::error::Confirmation required. Type CONFIRM to proceed"
            exit 1
          fi
      
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Setup branch protection
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const approvals = parseInt('${{ github.event.inputs.approval_count }}');
            const bypassAdmin = '${{ github.event.inputs.bypass_admin }}' === 'true';
            
            console.log('Applying protection with ' + approvals + ' required approvals');
            console.log('Admin bypass: ' + bypassAdmin);
            
            for (const branch of ['main', 'master']) {
              try {
                await github.rest.repos.updateBranchProtection({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  branch: branch,
                  required_status_checks: null,
                  enforce_admins: !bypassAdmin,
                  required_pull_request_reviews: {
                    required_approving_review_count: approvals,
                    dismiss_stale_reviews: true,
                    require_code_owner_reviews: true
                  },
                  restrictions: null,
                  allow_force_pushes: false,
                  allow_deletions: false,
                  required_conversation_resolution: true
                });
                console.log('[SUCCESS] Protected ' + branch + ' branch');
              } catch (e) {
                if (e.status === 404) {
                  console.log('[SKIP] Branch ' + branch + ' not found');
                } else {
                  console.error('[FAILED] Could not protect ' + branch + ': ' + e.message);
                  throw e;
                }
              }
            }
      
      - name: Create or update branch protection for PR branches
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            console.log('Setting up branch protection rules to allow PR creation from any branch');
            console.log('PR branches will be allowed to push and open PRs without restrictions');

  create-security-guidelines:
    name: Post Security Guidelines
    needs: [validate-user, apply-protection]
    if: |
      needs.validate-user.outputs.authorized == 'true' && 
      github.event.inputs.action == 'lock-it-down' &&
      needs.apply-protection.result == 'success'
    runs-on: ubuntu-latest
    steps:
      - name: Post security guideline issue
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const maintainer = '${{ github.event.inputs.maintainer_username }}';
            const owner = '${{ github.repository_owner }}';
            const reviewers = maintainer ? '@' + owner + ' and @' + maintainer : '@' + owner;
            const approvals = '${{ github.event.inputs.approval_count }}';

            const existing = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: ['security-guidelines'],
              state: 'open'
            });
            
            for (const issue of existing.data) {
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                state: 'closed',
                state_reason: 'completed'
              });
              console.log('Closed previous security guidelines issue #' + issue.number);
            }

            const newIssue = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: 'LOCKDOWN: Security Rules and Contribution Guidelines',
              body: '# Repository Security Rules\n\n' +
                    'This repository is under strict security protection.\n\n' +
                    '---\n\n' +
                    '## Allowed Actions\n' +
                    '- Branch off main or master\n' +
                    '- Open pull requests for changes\n' +
                    '- Pass the security-scan check\n' +
                    '- Get ' + approvals + ' approvals plus code owner review\n' +
                    '- Fix issues raised in reviews\n\n' +
                    '## Forbidden Actions\n' +
                    '- Direct pushes to protected branches\n' +
                    '- Merging PRs without required approvals\n' +
                    '- Merging with failing security-scan\n' +
                    '- Merging with unresolved conversations\n' +
                    '- Adding forbidden files (.pem, .key, .p12, .env, /secrets/)\n' +
                    '- Committing secrets (tokens, API keys, passwords, private keys)\n' +
                    '- Force pushing or deleting branches\n\n' +
                    '---\n\n' +
                    'WARNING: PRs with forbidden files or secrets will be automatically CLOSED by the bot.\n\n' +
                    'Maintainers: ' + reviewers + '\n' +
                    'Activated by: @${{ github.actor }}\n' +
                    'This issue is pinned for contributor reference',
              labels: ['security-guidelines', 'documentation', 'pinned']
            });
            
            console.log('Created security guidelines issue #' + newIssue.data.number);

  security-scan:
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Scan for secrets and forbidden files
        id: scan
        continue-on-error: true
        run: |
          echo "Starting security scan on PR changes only..."
          
          # Get the base branch
          base_sha="${{ github.event.pull_request.base.sha }}"
          head_sha="${{ github.event.pull_request.head.sha }}"
          
          echo "Scanning changes between $base_sha and $head_sha"
          
          # Get only the files changed in this PR
          changed_files=$(git diff --name-only "$base_sha" "$head_sha" 2>/dev/null || true)
          
          if [ -z "$changed_files" ]; then
            echo "No files changed in this PR"
            echo "scan_result=passed" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "Files changed in this PR:"
          echo "$changed_files"
          echo ""
          
          # Check for forbidden file types in PR changes only
          forbidden_found=0
          echo "$changed_files" | while IFS= read -r file; do
            if [ -f "$file" ]; then
              case "$file" in
                *.pem|*.key|*.p12|*.env)
                  echo "::warning::Forbidden file type detected: $file"
                  forbidden_found=1
                  ;;
                */secrets/*)
                  echo "::warning::File in forbidden directory: $file"
                  forbidden_found=1
                  ;;
              esac
            fi
          done
          
          # Check for potential secrets in changed files only
          secrets_found=0
          echo "$changed_files" | while IFS= read -r file; do
            if [ -f "$file" ]; then
              # Skip workflow files and config files in .github
              if [[ "$file" == .github/* ]]; then
                echo "Skipping repository file: $file"
                continue
              fi
              
              # Check for secrets with specific patterns
              if grep -l -E "(AKIA[0-9A-Z]{16}|ghp_[a-zA-Z0-9]{36}|gho_[a-zA-Z0-9]{36}|github_pat_[a-zA-Z0-9]{22}_[a-zA-Z0-9]{59})" "$file" >/dev/null 2>&1; then
                echo "::warning::Potential AWS or GitHub secrets found in: $file"
                secrets_found=1
              elif grep -l -E "(sk-[a-zA-Z0-9]{48}|api[_-]?key['\"]?\s*[:=]\s*['\"][a-zA-Z0-9]{32,})" "$file" >/dev/null 2>&1; then
                echo "::warning::Potential API keys found in: $file"
                secrets_found=1
              fi
            fi
          done
          
          if [ $forbidden_found -eq 1 ] || [ $secrets_found -eq 1 ]; then
            echo "scan_result=warning" >> $GITHUB_OUTPUT
            echo "Security warnings detected - please review"
          else
            echo "scan_result=passed" >> $GITHUB_OUTPUT
            echo "Security scan passed successfully"
          fi
      
      - name: Comment on PR with scan results
        if: github.event_name == 'pull_request' && always()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const scanResult = '${{ steps.scan.outputs.scan_result }}';
            const prNumber = context.issue.number;
            
            let body = '';
            if (scanResult === 'passed') {
              body = '### Security Scan Results\n\n' +
                     'Status: PASSED\n\n' +
                     'All security checks completed successfully:\n' +
                     '- No forbidden files detected (.pem, .key, .p12, .env, /secrets/)\n' +
                     '- No potential secrets found in changes\n\n' +
                     'This PR is clear for code review.\n\n' +
                     '---\n' +
                     'Awaiting maintainer approval. Maintainers can approve by commenting:\n' +
                     '- `/bot approve` - Approve and allow merge\n' +
                     '- `/bot reject` - Reject with reason';
            } else if (scanResult === 'warning') {
              body = '### Security Scan Results\n\n' +
                     'Status: WARNING\n\n' +
                     'Potential security issues detected. Please review:\n' +
                     '- Check for forbidden file types (.pem, .key, .p12, .env)\n' +
                     '- Check for files in /secrets/ directory\n' +
                     '- Check for potential secrets (API keys, tokens)\n\n' +
                     'The PR is still open, but maintainer review is required before merging.\n\n' +
                     '---\n' +
                     'Maintainers can approve by commenting:\n' +
                     '- `/bot approve` - Approve and allow merge\n' +
                     '- `/bot reject [reason]` - Reject with reason';
            } else {
              body = '### Security Scan Results\n\n' +
                     'Status: PASSED (No changes to scan)\n\n' +
                     'This PR is ready for review.';
            }
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: body
            });

  bot-command-handler:
    name: Handle Bot Commands
    runs-on: ubuntu-latest
    if: github.event_name == 'issue_comment' && github.event.issue.pull_request
    steps:
      - name: Check if commenter is authorized
        id: auth_check
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const commenter = context.payload.comment.user.login;
            const owner = context.repo.owner;
            const maintainer = process.env.MAINTAINER_USERNAME || '';
            
            const isAuthorized = commenter === owner || commenter === maintainer;
            core.setOutput('authorized', isAuthorized);
            core.setOutput('commenter', commenter);
            
            return isAuthorized;
      
      - name: Process bot command
        if: steps.auth_check.outputs.authorized == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const comment = context.payload.comment.body.trim().toLowerCase();
            const prNumber = context.issue.number;
            const commenter = '${{ steps.auth_check.outputs.commenter }}';
            
            if (comment.startsWith('/bot approve')) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: '### PR Approved by Maintainer\n\n' +
                      'Approved by: @' + commenter + '\n\n' +
                      'This PR has been reviewed and approved. ' +
                      'Once all required approvals are met and checks pass, this PR can be merged.\n\n' +
                      'Status: APPROVED'
              });
              
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                labels: ['approved', 'ready-to-merge']
              });
              
              console.log('PR #' + prNumber + ' approved by ' + commenter);
              
            } else if (comment.startsWith('/bot reject')) {
              const reason = comment.replace('/bot reject', '').trim() || 'No reason provided';
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: '### PR Rejected by Maintainer\n\n' +
                      'Rejected by: @' + commenter + '\n' +
                      'Reason: ' + reason + '\n\n' +
                      'Please address the feedback and request review again.\n\n' +
                      'Status: CHANGES REQUESTED'
              });
              
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                labels: ['changes-requested']
              });
              
              console.log('PR #' + prNumber + ' rejected by ' + commenter);
              
            } else if (comment.startsWith('/bot')) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: '### Unknown Bot Command\n\n' +
                      'Available commands:\n' +
                      '- `/bot approve` - Approve this PR\n' +
                      '- `/bot reject [reason]` - Reject with optional reason\n\n' +
                      'Only repository maintainers can use bot commands.'
              });
            }
      
      - name: Unauthorized command attempt
        if: steps.auth_check.outputs.authorized == 'false'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const comment = context.payload.comment.body.trim();
            if (comment.toLowerCase().startsWith('/bot')) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: 'Sorry, only repository maintainers can use bot commands.'
              });
            }
